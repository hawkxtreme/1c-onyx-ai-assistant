
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ПрограммныйИнтерфейс

Перем МД_ОпределенияСносок;

Функция СформироватьHTMLЧата(История) Экспорт
	
	Если ТипЗнч(История) <> Тип("Массив") Тогда
		История = Новый Массив;
	КонецЕсли;
	
	ОтсортированнаяИстория = ОтсортироватьСообщенияПоИдентификатору(История);
	
	HTML = Новый ТекстовыйДокумент;
	HTML.ДобавитьСтроку("<!DOCTYPE html>");
	HTML.ДобавитьСтроку("<html>");
	HTML.ДобавитьСтроку("<head>");
	HTML.ДобавитьСтроку("<meta charset=""UTF-8"">");
	HTML.ДобавитьСтроку("<style>");
	HTML.ДобавитьСтроку("body { margin: 0; padding: 12px 16px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 13px; line-height: 1.5; background: #eef0f4; color: #1f2933; }");
	HTML.ДобавитьСтроку(".chat-container { max-width: 100%; display: flex; flex-direction: column; padding-right: 4px; }");
	HTML.ДобавитьСтроку(".message { margin-bottom: 14px; padding: 12px 14px; border-radius: 12px; max-width: 78%; word-wrap: break-word; line-height: 1.5; display: flex; flex-direction: column; gap: 6px; box-shadow: 0 1px 4px rgba(15, 23, 42, 0.08); transition: transform 0.12s ease, box-shadow 0.12s ease; }");
	HTML.ДобавитьСтроку(".message:last-child { margin-bottom: 0; }");
	HTML.ДобавитьСтроку(".message:hover { transform: translateY(-1px); box-shadow: 0 6px 14px rgba(15, 23, 42, 0.10); }");
	HTML.ДобавитьСтроку(".user-message { background: linear-gradient(135deg, #0f62fe, #3b82f6); color: #ffffff; margin-left: auto; margin-right: 0; text-align: right; border: none; }");
	HTML.ДобавитьСтроку(".assistant-message { background: #ffffff; color: #1f2933; margin-right: auto; margin-left: 0; border: 1px solid #d7dde5; }");
	HTML.ДобавитьСтроку(".system-message { background: #fff7e6; color: #8a6200; margin: 0 auto; text-align: center; font-style: italic; max-width: 88%; border: 1px dashed #f2c97d; }");
	HTML.ДобавитьСтроку(".message-time { font-size: 11px; opacity: 0.65; margin-top: 2px; }");
	HTML.ДобавитьСтроку(".message-text { white-space: pre-wrap; font-size: 13px; }");
	HTML.ДобавитьСтроку(".user-message .message-text { color: #ffffff; }");
	HTML.ДобавитьСтроку(".user-message .message-time { color: rgba(255, 255, 255, 0.78); opacity: 1; }");
	HTML.ДобавитьСтроку(".message-text a { color: #0f62fe; text-decoration: none; }");
	HTML.ДобавитьСтроку(".message-text a:hover { text-decoration: underline; }");
	HTML.ДобавитьСтроку(".message-text ul, .message-text ol { margin: 6px 0 6px 16px; padding-left: 4px; }");
	HTML.ДобавитьСтроку(".message-text li { margin: 3px 0; }");
	HTML.ДобавитьСтроку(".message-text h1, .message-text h2, .message-text h3, .message-text h4, .message-text h5, .message-text h6 { margin: 10px 0 6px; font-weight: 600; color: #111827; }");
	HTML.ДобавитьСтроку(".message-text table { border-collapse: collapse; width: 100%; margin: 10px 0; border: 1px solid #d7dde5; }");
	HTML.ДобавитьСтроку(".message-text table th { border: 1px solid #d7dde5; padding: 8px 12px; text-align: left; background-color: #f8f9fa; font-weight: 600; }");
	HTML.ДобавитьСтроку(".message-text table td { border: 1px solid #d7dde5; padding: 8px 12px; }");
	HTML.ДобавитьСтроку(".message-text del { text-decoration: line-through; }");
	HTML.ДобавитьСтроку(".message-text u { text-decoration: underline; }");
	HTML.ДобавитьСтроку(".message-text kbd { background-color: #f4f4f4; border: 1px solid #ccc; border-radius: 3px; padding: 2px 6px; font-family: monospace; }");
	HTML.ДобавитьСтроку(".message-text code { background: rgba(15, 23, 42, 0.08); padding: 2px 5px; border-radius: 4px; font-size: 12px; font-family: 'Consolas', 'Courier New', monospace; }");
	HTML.ДобавитьСтроку(".user-message .message-text code { background: rgba(255, 255, 255, 0.22); color: #ffffff; }");
	HTML.ДобавитьСтроку(".message-text pre { background: #101828; color: #f3f4f6; padding: 12px; border-radius: 8px; overflow: auto; font-size: 12px; line-height: 1.45; }");
	HTML.ДобавитьСтроку(".message-text pre code { background: transparent; color: inherit; padding: 0; }");
	HTML.ДобавитьСтроку(".typing-indicator { background: #ffffff; color: #1f2933; margin-right: auto; margin-left: 0; border: 1px dashed #94a3b8; opacity: 0.85; }");
	HTML.ДобавитьСтроку(".typing-text { display: flex; align-items: center; gap: 6px; font-style: italic; }");
	HTML.ДобавитьСтроку(".typing-dot { width: 6px; height: 6px; background: #2563eb; border-radius: 50%; opacity: 0.35; animation: typingBlink 1.2s infinite ease-in-out; }");
	HTML.ДобавитьСтроку(".typing-dot:nth-child(2) { animation-delay: 0.2s; }");
	HTML.ДобавитьСтроку(".typing-dot:nth-child(3) { animation-delay: 0.4s; }");
	HTML.ДобавитьСтроку("@keyframes typingBlink { 0%, 80%, 100% { opacity: 0.2; transform: translateY(0); } 40% { opacity: 0.85; transform: translateY(-2px); } }");
	HTML.ДобавитьСтроку("</style>");
	HTML.ДобавитьСтроку("</head>");
	HTML.ДобавитьСтроку("<body>");
	HTML.ДобавитьСтроку("<div class=""chat-container"">");
	
	Для Каждого Сообщение Из ОтсортированнаяИстория Цикл
		
		Если ТипЗнч(Сообщение) <> Тип("Структура") Тогда
			Продолжить;
		КонецЕсли;
		
		ТипСообщения = "";
		Если Сообщение.Свойство("message_type") Тогда
			ТипСообщения = НРег(СокрЛП(Сообщение.message_type));
		КонецЕсли;
		
		ТекстСообщения = "";
		Если Сообщение.Свойство("message") Тогда
			ТекстСообщения = Строка(Сообщение.message);
		КонецЕсли;
		
		Если ПустаяСтрока(ТекстСообщения) Тогда
			Продолжить;
		КонецЕсли;
		
		КлассCSS = "message";
		Если ТипСообщения = "user" Тогда
			КлассCSS = КлассCSS + " user-message";
		ИначеЕсли ТипСообщения = "assistant" Тогда
			КлассCSS = КлассCSS + " assistant-message";
		Иначе
			КлассCSS = КлассCSS + " system-message";
		КонецЕсли;
		
		Если ТипСообщения = "assistant" Тогда
			ТекстСообщенияHTML = ПреобразоватьMarkdownВHTML(ТекстСообщения);
		Иначе
			ТекстСообщенияHTML = ЭкранироватьHTML(ТекстСообщения);
		КонецЕсли;
		
		ВремяОтправки = "";
		Если Сообщение.Свойство("time_sent") И ЗначениеЗаполнено(Сообщение.time_sent) Тогда
			Если ТипЗнч(Сообщение.time_sent) = Тип("Дата") Тогда
				ВремяОтправки = Формат(Сообщение.time_sent, "ДФ='dd.MM.yyyy HH:mm'");
			Иначе
				ВремяОтправки = "";
			КонецЕсли;
		КонецЕсли;
		
		HTML.ДобавитьСтроку(СтрШаблон("<div class=""%1"">", КлассCSS));
		HTML.ДобавитьСтроку(СтрШаблон("<div class=""message-text"">%1</div>", ТекстСообщенияHTML));
		Если Не ПустаяСтрока(ВремяОтправки) Тогда
			HTML.ДобавитьСтроку(СтрШаблон("<div class=""message-time"">%1</div>", ВремяОтправки));
		КонецЕсли;
		HTML.ДобавитьСтроку("</div>");
		
	КонецЦикла;

	HTML.ДобавитьСтроку("<div id=""chat-scroll-anchor"" style=""height:1px;""></div>");
	HTML.ДобавитьСтроку("</div>");
	HTML.ДобавитьСтроку("<script>");
	HTML.ДобавитьСтроку("(function () {");
	HTML.ДобавитьСтроку("    try {");
	HTML.ДобавитьСтроку("        var scrollToBottom = function () {");
	HTML.ДобавитьСтроку("            var container = document.querySelector('.chat-container');");
	HTML.ДобавитьСтроку("            if (container) {");
	HTML.ДобавитьСтроку("                container.scrollTop = container.scrollHeight;");
	HTML.ДобавитьСтроку("            }");
	HTML.ДобавитьСтроку("            if (typeof window !== 'undefined' && window.scrollTo) {");
	HTML.ДобавитьСтроку("                window.scrollTo(0, document.body.scrollHeight || 0);");
	HTML.ДобавитьСтроку("            }");
	HTML.ДобавитьСтроку("            var anchor = document.getElementById('chat-scroll-anchor');");
	HTML.ДобавитьСтроку("            if (anchor && anchor.scrollIntoView) {");
	HTML.ДобавитьСтроку("                anchor.scrollIntoView(false);");
	HTML.ДобавитьСтроку("            }");
	HTML.ДобавитьСтроку("        };");
	HTML.ДобавитьСтроку("        if (document.readyState === 'loading') {");
	HTML.ДобавитьСтроку("            document.addEventListener('DOMContentLoaded', function () {");
	HTML.ДобавитьСтроку("                setTimeout(scrollToBottom, 50);");
	HTML.ДобавитьСтроку("            });");
	HTML.ДобавитьСтроку("        } else {");
	HTML.ДобавитьСтроку("            setTimeout(scrollToBottom, 50);");
	HTML.ДобавитьСтроку("        }");
	HTML.ДобавитьСтроку("    } catch (e) {");
	HTML.ДобавитьСтроку("    }");
	HTML.ДобавитьСтроку("})();");
	HTML.ДобавитьСтроку("</script>");
	HTML.ДобавитьСтроку("</body>");
	HTML.ДобавитьСтроку("</html>");
	
	Возврат HTML.ПолучитьТекст();
	
КонецФункции

Функция ПолучитьHTMLИсторииЧата(Знач СсылкаСессии) Экспорт

	Если Не ЗначениеЗаполнено(СсылкаСессии) Тогда
		Возврат СформироватьHTMLЧата(Новый Массив);
	КонецЕсли;

	ИдентификаторСессии = ПолучитьИдентификаторПоСсылке(СсылкаСессии);
	Если Не ЗначениеЗаполнено(ИдентификаторСессии) Тогда
		Возврат СформироватьHTMLОшибки(НСтр("ru='Не удалось определить идентификатор сессии'"));
	КонецЕсли;

	Попытка
		История = onyx_РаботаССессиямиЧата.ПолучитьИсториюСессии(ИдентификаторСессии);
		Возврат СформироватьHTMLЧата(История);
	Исключение
		Возврат СформироватьHTMLОшибки(ОписаниеОшибки());
	КонецПопытки;

КонецФункции

Функция ПолучитьHTMLЧатаСИндикатором(Знач СсылкаСессии, Знач ИмяАгента, Знач ТекстПользователя = Неопределено) Экспорт
 
 	Если Не ЗначениеЗаполнено(СсылкаСессии) Тогда
		Возврат СформироватьHTMLЧата(Новый Массив);
 	КонецЕсли;
 
 	ИдентификаторСессии = ПолучитьИдентификаторПоСсылке(СсылкаСессии);
 	Если Не ЗначениеЗаполнено(ИдентификаторСессии) Тогда
		Возврат СформироватьHTMLЧата(Новый Массив);
 	КонецЕсли;
 
 	Попытка
		История = onyx_РаботаССессиямиЧата.ПолучитьИсториюСессии(ИдентификаторСессии);
		
		Если ЗначениеЗаполнено(ТекстПользователя) Тогда
			Если ТипЗнч(История) <> Тип("Массив") Тогда
				История = Новый Массив;
			КонецЕсли;
			
			ВременноеСообщение = Новый Структура;
			ВременноеСообщение.Вставить("message_type", "user");
			ВременноеСообщение.Вставить("message", ТекстПользователя);
			ВременноеСообщение.Вставить("time_sent", ТекущаяДатаСеанса());
			
			// Гарантируем размещение сообщения в конце ленты
			ВременноеСообщение.Вставить("message_id", 900000000000000000 + История.Количество());
			
			История.Добавить(ВременноеСообщение);
		КонецЕсли;
		
		HTMLЧата = СформироватьHTMLЧата(История);
		Возврат ДобавитьИндикаторПечати(HTMLЧата, ИмяАгента);
 	Исключение
 		Возврат СформироватьHTMLОшибки(ОписаниеОшибки());
 	КонецПопытки;
 
 КонецФункции

#КонецОбласти

#Область ОбработчикиСобытий

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ОтсортироватьСообщенияПоИдентификатору(История)
	
	Если ТипЗнч(История) <> Тип("Массив") ИЛИ История.Количество() = 0 Тогда
		Возврат История;
	КонецЕсли;
	
	ТаблицаСообщений = Новый ТаблицаЗначений;
	ТаблицаСообщений.Колонки.Добавить("message_id", Новый ОписаниеТипов("Число"));
	ТаблицаСообщений.Колонки.Добавить("time_sent", Новый ОписаниеТипов("Дата"));
	ТаблицаСообщений.Колонки.Добавить("Сообщение");
	
	Для Каждого Сообщение Из История Цикл
		Если ТипЗнч(Сообщение) = Тип("Структура") Тогда
			НоваяСтрока = ТаблицаСообщений.Добавить();
			НоваяСтрока.Сообщение = Сообщение;
			
			Если Сообщение.Свойство("message_id") Тогда
				Если ТипЗнч(Сообщение.message_id) = Тип("Число") Тогда
					НоваяСтрока.message_id = Сообщение.message_id;
				ИначеЕсли ТипЗнч(Сообщение.message_id) = Тип("Строка") Тогда
					НоваяСтрока.message_id = БезопасноПреобразоватьСтрокуВЧисло(Сообщение.message_id);
					Если НоваяСтрока.message_id = Неопределено Тогда
						НоваяСтрока.message_id = 0;
					КонецЕсли;
				Иначе
					НоваяСтрока.message_id = 0;
				КонецЕсли;
			Иначе
				НоваяСтрока.message_id = 0;
			КонецЕсли;
			
			Если Сообщение.Свойство("time_sent") И ЗначениеЗаполнено(Сообщение.time_sent) Тогда
				Если ТипЗнч(Сообщение.time_sent) = Тип("Дата") Тогда
					НоваяСтрока.time_sent = Сообщение.time_sent;
				Иначе
					НоваяСтрока.time_sent = '00010101';
				КонецЕсли;
			Иначе
				НоваяСтрока.time_sent = '00010101';
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	ТаблицаСообщений.Сортировать("message_id, time_sent");
	
	ОтсортированнаяИстория = Новый Массив;
	Для Каждого Строка Из ТаблицаСообщений Цикл
		ОтсортированнаяИстория.Добавить(Строка.Сообщение);
	КонецЦикла;
	
	Возврат ОтсортированнаяИстория;
	
КонецФункции

// Безопасно преобразует строку в число.
// Если преобразование невозможно, возвращает Неопределено.
// Параметры:
//   СтрокаЧисла - Строка - строка для преобразования.
// Возвращаемое значение:
//   Число - преобразованное число или Неопределено, если преобразование невозможно.
Функция БезопасноПреобразоватьСтрокуВЧисло(СтрокаЧисла)
	
	Если ПустаяСтрока(СтрокаЧисла) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		Возврат Число(СтрокаЧисла);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

Функция ПреобразоватьMarkdownВHTML(Знач Текст)
	
	Если ПустаяСтрока(СокрЛП(Текст)) Тогда
		Возврат "";
	КонецЕсли;
	
	НормализованныйТекст = СтрЗаменить(Текст, Символы.ВК, Символы.ПС);
	
	// Обрабатываем определения сносок ([текст][1]) до парсинга токенов
	МД_ОпределенияСносок = Новый Соответствие;
	СтруктураСносок = МД_ИзвлечьОпределенияСносок(НормализованныйТекст);
	Если СтруктураСносок <> Неопределено Тогда
		Если СтруктураСносок.Свойство("Текст") Тогда
			НормализованныйТекст = СтруктураСносок.Текст;
		КонецЕсли;
		Если СтруктураСносок.Свойство("Сноски") Тогда
			МД_ОпределенияСносок = СтруктураСносок.Сноски;
		КонецЕсли;
	КонецЕсли;
	
	ТокеныMarkdown = МД_ПолучитьТокены(НормализованныйТекст);
	
	Если ТокеныMarkdown.Количество() = 0 Тогда
		Возврат ЭкранироватьHTML(НормализованныйТекст);
	КонецЕсли;
	
	РезультатHTML = МД_СформироватьHTMLИзТокенов(ТокеныMarkdown);
	МД_ОпределенияСносок = Неопределено;
	
	// Объединяем последовательные списки одного типа
	РезультатHTML = МД_ОбъединитьПоследовательныеСписки(РезультатHTML);
	
	Возврат РезультатHTML;
	
КонецФункции

#Область MarkdownПарсерV2

Функция МД_ПолучитьТокены(Знач Текст)
	
	Токены = Новый Массив;
	Строки = СтрРазделить(Текст, Символы.ПС, Ложь);
	Если Строки = Неопределено Тогда
		Возврат Токены;
	КонецЕсли;
	
	ВсегоСтрок = Строки.ВГраница();
	Индекс = 0;
	
	Пока Индекс <= ВсегоСтрок Цикл
		
		ТекущаяСтрока = Строки[Индекс];
		ОбрезаннаяСтрока = СокрЛП(ТекущаяСтрока);
		
		Если ПустаяСтрока(ОбрезаннаяСтрока) Тогда
			Индекс = Индекс + 1;
			Продолжить;
		КонецЕсли;
		
		Если СтрНачинаетсяС(ОбрезаннаяСтрока, "```") Тогда
			РезультатЧтения = МД_ПрочитатьКодФенс(Строки, Индекс);
			Токены.Добавить(РезультатЧтения.Токен);
			Индекс = РезультатЧтения.СледующаяСтрока;
			Продолжить;
		КонецЕсли;
		
		Если СтрНачинаетсяС(ОбрезаннаяСтрока, "$$") Тогда
			РезультатЧтения = МД_ПрочитатьМатематическийБлок(Строки, Индекс);
			Токены.Добавить(РезультатЧтения.Токен);
			Индекс = РезультатЧтения.СледующаяСтрока;
			Продолжить;
		КонецЕсли;
		
		Если МД_СтрокаНачинаетсяСHTMLБлока(ОбрезаннаяСтрока) Тогда
			РезультатЧтения = МД_ПрочитатьHTMLБлок(Строки, Индекс);
			Токены.Добавить(РезультатЧтения.Токен);
			Индекс = РезультатЧтения.СледующаяСтрока;
			Продолжить;
		КонецЕсли;
		
		Если МД_ЭтоГоризонтальнаяЛиния(ОбрезаннаяСтрока) Тогда
			Токены.Добавить(МД_СоздатьТокен("hr", ""));
			Индекс = Индекс + 1;
			Продолжить;
		КонецЕсли;
		
		Если МД_ЭтоНачалоТаблицы(Строки, Индекс) Тогда
			РезультатЧтения = МД_ПрочитатьТаблицу(Строки, Индекс);
			Токены.Добавить(РезультатЧтения.Токен);
			Индекс = РезультатЧтения.СледующаяСтрока;
			Продолжить;
		КонецЕсли;
		
		УровеньЗаголовка = МД_ПолучитьУровеньЗаголовка(ОбрезаннаяСтрока);
		Если УровеньЗаголовка > 0 Тогда
			ТекстЗаголовка = СокрЛП(Сред(ОбрезаннаяСтрока, УровеньЗаголовка + 2));
			Токен = МД_СоздатьТокен("heading", ТекстЗаголовка);
			Токен.Дополнительно.Вставить("Уровень", УровеньЗаголовка);
			Токены.Добавить(Токен);
			Индекс = Индекс + 1;
			Продолжить;
		КонецЕсли;
		
		Если СтрНачинаетсяС(ОбрезаннаяСтрока, ">") Тогда
			РезультатЧтения = МД_ПрочитатьЦитату(Строки, Индекс);
			Токены.Добавить(РезультатЧтения.Токен);
			Если РезультатЧтения.Свойство("СледующаяСтрока") Тогда
				Индекс = РезультатЧтения.СледующаяСтрока;
			Иначе
				Индекс = Индекс + 1;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		Если МД_ЭтоМаркированныйЭлемент(ТекущаяСтрока) ИЛИ МД_ЭтоНумерованныйЭлемент(ТекущаяСтрока) Тогда
			РезультатЧтения = МД_ПрочитатьСписковыйБлок(Строки, Индекс);
			Токены.Добавить(РезультатЧтения.Токен);
			Если РезультатЧтения.Свойство("СледующаяСтрока") Тогда
				Индекс = РезультатЧтения.СледующаяСтрока;
			Иначе
				Индекс = Индекс + 1;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		РезультатЧтения = МД_ПрочитатьПараграф(Строки, Индекс);
		Токены.Добавить(РезультатЧтения.Токен);
		Если РезультатЧтения.Свойство("СледующаяСтрока") Тогда
			Индекс = РезультатЧтения.СледующаяСтрока;
		Иначе
			Индекс = Индекс + 1;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Токены;
	
КонецФункции

Функция МД_СоздатьТокен(Знач Тип, Знач Текст)
	Токен = Новый Структура;
	Токен.Вставить("Тип", Тип);
	Токен.Вставить("Текст", Текст);
	Токен.Вставить("Дочерние", Новый Массив);
	Токен.Вставить("Дополнительно", Новый Структура);
	Возврат Токен;
КонецФункции

Функция МД_ЭтоГоризонтальнаяЛиния(Знач Строка)
	Если ПустаяСтрока(Строка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Строка = "---" ИЛИ Строка = "***" ИЛИ Строка = "___";
КонецФункции

Функция МД_ПолучитьУровеньЗаголовка(Знач Строка)
	Если Не СтрНачинаетсяС(Строка, "#") Тогда
		Возврат 0;
	КонецЕсли;
	
	Счетчик = 0;
	Для Индекс = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Индекс, 1);
		Если Символ = "#" Тогда
			Счетчик = Счетчик + 1;
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Счетчик > 6 Тогда
		Счетчик = 6;
	КонецЕсли;
	
	Возврат Счетчик;
КонецФункции

Функция МД_ЭтоНачалоТаблицы(Строки, Индекс)
	Если Индекс + 1 > Строки.ВГраница() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не МД_СтрокаТаблицы(Строки[Индекс]) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат МД_СтрокаЯвляетсяРазделителемТаблицы(Строки[Индекс + 1]);
КонецФункции

Функция МД_СтрокаТаблицы(Знач Строка)
	Обрезанная = СокрЛП(Строка);
	Возврат (СтрНайти(Обрезанная, "|") > 0);
КонецФункции

Функция МД_СтрокаЯвляетсяРазделителемТаблицы(Знач Строка)
	Обрезанная = СокрЛП(Строка);
	Если ПустаяСтрока(Обрезанная) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Индекс = 1 По СтрДлина(Обрезанная) Цикл
		Символ = Сред(Обрезанная, Индекс, 1);
		Если Символ <> "|" И Символ <> "-" И Символ <> ":" И Символ <> " " Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрНайти(Обрезанная, "-") > 0;
КонецФункции

Функция МД_ПрочитатьКодФенс(Строки, НачальныйИндекс)
	
	ОткрывающаяСтрока = СокрЛП(Строки[НачальныйИндекс]);
	Язык = "";
	Если СтрДлина(ОткрывающаяСтрока) > 3 Тогда
		Язык = СокрЛП(Сред(ОткрывающаяСтрока, 4));
	КонецЕсли;
	
	Содержимое = Новый Массив;
	Индекс = НачальныйИндекс + 1;
	
	Пока Индекс <= Строки.ВГраница() Цикл
		Текущая = Строки[Индекс];
		Если СтрНачинаетсяС(СокрЛП(Текущая), "```") Тогда
			Индекс = Индекс + 1;
			Прервать;
		КонецЕсли;
		Содержимое.Добавить(Текущая);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Токен = МД_СоздатьТокен("codeblock", СоединитьСтроки(Содержимое, Символы.ПС));
	Токен.Дополнительно.Вставить("Язык", Язык);
	
	Возврат Новый Структура("Токен,СледующаяСтрока", Токен, Индекс);
	
КонецФункции

Функция МД_ПрочитатьМатематическийБлок(Строки, НачальныйИндекс)
	
	Содержимое = Новый Массив;
	Индекс = НачальныйИндекс;
	
	// Удаляем начальные "$$"
	ПерваяСтрока = СокрЛП(Строки[Индекс]);
	Если СтрДлина(ПерваяСтрока) > 2 Тогда
		Содержимое.Добавить(Сред(ПерваяСтрока, 3));
	КонецЕсли;
	Индекс = Индекс + 1;
	
	Пока Индекс <= Строки.ВГраница() Цикл
		Текущая = Строки[Индекс];
		Если СтрНачинаетсяС(СокрЛП(Текущая), "$$") Тогда
			Закрывающая = СокрЛП(Текущая);
			Если СтрДлина(Закрывающая) > 2 Тогда
				Содержимое.Добавить(Лев(Закрывающая, СтрДлина(Закрывающая) - 2));
			КонецЕсли;
			Индекс = Индекс + 1;
			Прервать;
		КонецЕсли;
		Содержимое.Добавить(Текущая);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Токен = МД_СоздатьТокен("math_block", СоединитьСтроки(Содержимое, Символы.ПС));
	Возврат Новый Структура("Токен,СледующаяСтрока", Токен, Индекс);
	
КонецФункции

Функция МД_СтрокаНачинаетсяСHTMLБлока(Знач Строка)
	
	Если ПустаяСтрока(Строка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СтрНачинаетсяС(ВРег(Строка), "<DIV") Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция МД_ПрочитатьHTMLБлок(Строки, НачальныйИндекс)
	
	Индекс = НачальныйИндекс;
	Содержимое = Новый Массив;
	ОткрытыеDiv = 0;
	
	Пока Индекс <= Строки.ВГраница() Цикл
		Текущая = Строки[Индекс];
		Содержимое.Добавить(Текущая);
		
		НормализованнаяСтрока = ВРег(Текущая);
		КоличествоОткрытий = МД_КоличествоВхождений(НормализованнаяСтрока, "<DIV");
		КоличествоЗакрытий = МД_КоличествоВхождений(НормализованнаяСтрока, "</DIV>");
		ОткрытыеDiv = ОткрытыеDiv + КоличествоОткрытий - КоличествоЗакрытий;
		
		Если ОткрытыеDiv <= 0 Тогда
			Индекс = Индекс + 1;
			Прервать;
		КонецЕсли;
		
		Индекс = Индекс + 1;
	КонецЦикла;
	
	HTML = СоединитьСтроки(Содержимое, Символы.ПС);
	Токен = МД_СоздатьТокен("rawhtml", HTML);
	Возврат Новый Структура("Токен,СледующаяСтрока", Токен, Индекс);
	
КонецФункции

Функция МД_КоличествоВхождений(Знач Строка, Знач Подстрока)
	
	Если ПустаяСтрока(Подстрока) Тогда
		Возврат 0;
	КонецЕсли;
	
	Счетчик = 0;
	Позиция = СтрНайти(Строка, Подстрока);
	Пока Позиция > 0 Цикл
		Счетчик = Счетчик + 1;
		Строка = Сред(Строка, Позиция + СтрДлина(Подстрока));
		Позиция = СтрНайти(Строка, Подстрока);
	КонецЦикла;
	
	Возврат Счетчик;
	
КонецФункции

Функция МД_ПрочитатьТаблицу(Строки, НачальныйИндекс)
	
	Заголовок = Строки[НачальныйИндекс];
	СтрокаВыравнивания = "";
	Если НачальныйИндекс + 1 <= Строки.ВГраница() Тогда
		СтрокаВыравнивания = Строки[НачальныйИндекс + 1];
	КонецЕсли;
	Индекс = НачальныйИндекс + 2;
	СписокСтрок = Новый Массив;
	
	Пока Индекс <= Строки.ВГраница() Цикл
		Если Не МД_СтрокаТаблицы(Строки[Индекс]) Тогда
			Прервать;
		КонецЕсли;
		СписокСтрок.Добавить(Строки[Индекс]);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Заголовки = РазобратьСтрокуТаблицы(Заголовок);
	Выравнивания = МД_ПолучитьВыравниваниеСтолбцов(СтрокаВыравнивания, Заголовки.Количество());
	СтрокиТаблицы = Новый Массив;
	Для Каждого СтрокаТаблицы Из СписокСтрок Цикл
		СтрокиТаблицы.Добавить(РазобратьСтрокуТаблицы(СтрокаТаблицы));
	КонецЦикла;
	
	Токен = МД_СоздатьТокен("table", "");
	Токен.Дополнительно.Вставить("Заголовки", Заголовки);
	Токен.Дополнительно.Вставить("Строки", СтрокиТаблицы);
	Токен.Дополнительно.Вставить("Выравнивания", Выравнивания);
	
	Возврат Новый Структура("Токен,СледующаяСтрока", Токен, Индекс);
	
КонецФункции

Функция МД_ПолучитьВыравниваниеСтолбцов(Знач СтрокаРазделителя, Знач КоличествоСтолбцов)
	
	Выравнивания = Новый Массив;
	Если ПустаяСтрока(СтрокаРазделителя) Тогда
		Для Индекс = 1 По КоличествоСтолбцов Цикл
			Выравнивания.Добавить("left");
		КонецЦикла;
		Возврат Выравнивания;
	КонецЕсли;
	
	Части = РазобратьСтрокуТаблицы(СтрокаРазделителя);
	Для Индекс = 0 По КоличествоСтолбцов - 1 Цикл
		Если Индекс > Части.ВГраница() Тогда
			Выравнивания.Добавить("left");
			Продолжить;
		КонецЕсли;
		Часть = СокрЛП(Части[Индекс]);
		Выравнивание = "left";
		Если СтрНачинаетсяС(Часть, ":") И СтрЗаканчиваетсяНа(Часть, ":") Тогда
			Выравнивание = "center";
		ИначеЕсли СтрЗаканчиваетсяНа(Часть, ":") Тогда
			Выравнивание = "right";
		ИначеЕсли СтрНачинаетсяС(Часть, ":") Тогда
			Выравнивание = "left";
		КонецЕсли;
		Выравнивания.Добавить(Выравнивание);
	КонецЦикла;
	
	Возврат Выравнивания;
	
КонецФункции

Функция МД_ПолучитьСтильВыравнивания(Выравнивания, Индекс)
	
	Если Выравнивания = Неопределено Тогда
		Возврат "text-align: left;";
	КонецЕсли;
	
	Если Индекс > Выравнивания.ВГраница() Тогда
		Возврат "text-align: left;";
	КонецЕсли;
	
	Направление = ВРег(Выравнивания[Индекс]);
	Если Направление = "center" Тогда
		Возврат "text-align: center;";
	ИначеЕсли Направление = "right" Тогда
		Возврат "text-align: right;";
	Иначе
		Возврат "text-align: left;";
	КонецЕсли;
	
КонецФункции

Функция МД_ПрочитатьЦитату(Строки, НачальныйИндекс)
	
	Индекс = НачальныйИндекс;
	Содержимое = Новый Массив;
	
	Пока Индекс <= Строки.ВГраница() Цикл
		Если Не СтрНачинаетсяС(СокрЛП(Строки[Индекс]), ">") Тогда
			Прервать;
		КонецЕсли;
		СтрокаЦитаты = СокрЛП(Сред(СокрЛП(Строки[Индекс]), 2));
		Содержимое.Добавить(СтрокаЦитаты);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Токен = МД_СоздатьТокен("blockquote", СоединитьСтроки(Содержимое, Символы.ПС));
	Возврат Новый Структура("Токен,СледующаяСтрока", Токен, Индекс);
	
КонецФункции

Функция МД_ПрочитатьСписковыйБлок(Строки, НачальныйИндекс)
	
	Индекс = НачальныйИндекс;
	БлокТекста = Новый ТекстовыйДокумент;
	
	Пока Индекс <= Строки.ВГраница() Цикл
		
		Если ПустаяСтрока(СокрЛП(Строки[Индекс])) Тогда
			
			СледующийИндекс = Индекс + 1;
			КоличествоПустыхСтрок = 1;
			Пока СледующийИндекс <= Строки.ВГраница() И ПустаяСтрока(СокрЛП(Строки[СледующийИндекс])) Цикл
				СледующийИндекс = СледующийИндекс + 1;
				КоличествоПустыхСтрок = КоличествоПустыхСтрок + 1;
			КонецЦикла;
			
			// Если после пустых строк идет элемент списка того же типа, продолжаем читать список
			Если СледующийИндекс <= Строки.ВГраница() И (МД_ЭтоМаркированныйЭлемент(Строки[СледующийИндекс]) ИЛИ МД_ЭтоНумерованныйЭлемент(Строки[СледующийИндекс]) ИЛИ СтрНачинаетсяС(Строки[СледующийИндекс], "    ")) Тогда
				// Пропускаем пустые строки (они не добавляются в блок, так как в markdown пустые строки между элементами списка игнорируются)
				Индекс = СледующийИндекс;
				Продолжить;
			КонецЕсли;
			
			// Если пустых строк больше одной, список заканчивается
			Если КоличествоПустыхСтрок > 1 Тогда
				Индекс = СледующийИндекс;
				Прервать;
			КонецЕсли;
			
			// Если пустая строка одна, но после нее нет элемента списка, список заканчивается
			Индекс = СледующийИндекс;
			Прервать;
		КонецЕсли;
		
		Если Не МД_ЭтоМаркированныйЭлемент(Строки[Индекс]) И Не МД_ЭтоНумерованныйЭлемент(Строки[Индекс]) И Не СтрНачинаетсяС(Строки[Индекс], "    ") Тогда
			Прервать;
		КонецЕсли;
		
		БлокТекста.ДобавитьСтроку(Строки[Индекс]);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	HTML = ОбработатьМаркдаунСписки(БлокТекста.ПолучитьТекст());
	Токен = МД_СоздатьТокен("rawhtml", HTML);
	
	Возврат Новый Структура("Токен,СледующаяСтрока", Токен, Индекс);
	
КонецФункции

Функция МД_ПрочитатьПараграф(Строки, НачальныйИндекс)
	
	Индекс = НачальныйИндекс;
	Содержимое = Новый Массив;
	
	Пока Индекс <= Строки.ВГраница() Цикл
		
		Текущая = Строки[Индекс];
		Обрезанная = СокрЛП(Текущая);
		
		Если ПустаяСтрока(Обрезанная) Тогда
			Прервать;
		КонецЕсли;
		
		Если МД_СтрокаНачинаетНовыйБлок(Строки, Индекс) И Индекс <> НачальныйИндекс Тогда
			Прервать;
		КонецЕсли;
		
		Содержимое.Добавить(Текущая);
		Индекс = Индекс + 1;
		
	КонецЦикла;
	
	Токен = МД_СоздатьТокен("paragraph", СоединитьСтроки(Содержимое, Символы.ПС));
	Возврат Новый Структура("Токен,СледующаяСтрока", Токен, Индекс);
	
КонецФункции

Функция МД_СтрокаНачинаетНовыйБлок(Строки, Индекс)
	
	Если Индекс > Строки.ВГраница() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Обрезанная = СокрЛП(Строки[Индекс]);
	
	Если ПустаяСтрока(Обрезанная) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если СтрНачинаетсяС(Обрезанная, "```") Тогда Возврат Истина; КонецЕсли;
	Если МД_ЭтоГоризонтальнаяЛиния(Обрезанная) Тогда Возврат Истина; КонецЕсли;
	Если МД_ПолучитьУровеньЗаголовка(Обрезанная) > 0 Тогда Возврат Истина; КонецЕсли;
	Если СтрНачинаетсяС(Обрезанная, ">") Тогда Возврат Истина; КонецЕсли;
	Если МД_ЭтоМаркированныйЭлемент(Строки[Индекс]) Тогда Возврат Истина; КонецЕсли;
	Если МД_ЭтоНумерованныйЭлемент(Строки[Индекс]) Тогда Возврат Истина; КонецЕсли;
	Если МД_ЭтоНачалоТаблицы(Строки, Индекс) Тогда Возврат Истина; КонецЕсли;
	
	Возврат Ложь;
КонецФункции

Функция МД_ЭтоМаркированныйЭлемент(Знач Строка)
	Обрезанная = СокрЛП(Строка);
	Возврат СтрНачинаетсяС(Обрезанная, "- ") ИЛИ СтрНачинаетсяС(Обрезанная, "* ") ИЛИ СтрНачинаетсяС(Обрезанная, "+ ");
КонецФункции

Функция МД_ЭтоНумерованныйЭлемент(Знач Строка)
	Обрезанная = СокрЛП(Строка);
	ПозицияТочки = СтрНайти(Обрезанная, ".");
	Если ПозицияТочки = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ЧисловаяЧасть = Лев(Обрезанная, ПозицияТочки - 1);
	Если ПустаяСтрока(ЧисловаяЧасть) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ЗначениеЧисла = БезопасноПреобразоватьСтрокуВЧисло(ЧисловаяЧасть);
	Если ЗначениеЧисла = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СтрДлина(Обрезанная) <= ПозицияТочки + 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Сред(Обрезанная, ПозицияТочки + 1, 1) = " ";
КонецФункции

Функция МД_ПолучитьТекстЭлементаСписка(Знач Строка, Знач ТипСписка)
	Обрезанная = СокрЛП(Строка);
	Если ТипСписка = "ul" Тогда
		Возврат СокрЛП(Сред(Обрезанная, 3));
	КонецЕсли;
	
	ПозицияТочки = СтрНайти(Обрезанная, ".");
	Если ПозицияТочки = 0 Тогда
		Возврат Обрезанная;
	КонецЕсли;
	
	Возврат СокрЛП(Сред(Обрезанная, ПозицияТочки + 2));
КонецФункции

Функция МД_СформироватьHTMLИзТокенов(Токены)
	
	Если Токены.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Результат = "";
	Для Индекс = 0 По Токены.ВГраница() Цикл
		Токен = Токены[Индекс];
		БлокHTML = МД_РендерТокен(Токен);
		Если ПустаяСтрока(БлокHTML) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПустаяСтрока(Результат) Тогда
			Результат = БлокHTML;
		Иначе
			// Проверяем, не является ли текущий и предыдущий токены списками одного типа
			// Если да, объединяем их без <br>
			ТекущийНачинаетсяСОл = СтрНачинаетсяС(БлокHTML, "<ol");
			ТекущийНачинаетсяСУл = СтрНачинаетсяС(БлокHTML, "<ul");
			
			// Находим последнее вхождение закрывающих тегов списков
			ПозицияПоследнегоОл = СтрНайти(Результат, "</ol>", НаправлениеПоиска.СКонца);
			ПозицияПоследнегоУл = СтрНайти(Результат, "</ul>", НаправлениеПоиска.СКонца);
			
			ПредыдущийЗаканчиваетсяОл = Ложь;
			ПредыдущийЗаканчиваетсяУл = Ложь;
			
			// Проверяем, что после последнего закрывающего тега нет других тегов (кроме возможного <br>)
			Если ПозицияПоследнегоОл > 0 Тогда
				ПодстрокаПослеОл = СокрЛП(Сред(Результат, ПозицияПоследнегоОл + 5));
				// Если после </ol> пусто или только <br>, значит это последний закрывающий тег
				Если ПустаяСтрока(ПодстрокаПослеОл) ИЛИ ПодстрокаПослеОл = "<br>" Тогда
					ПредыдущийЗаканчиваетсяОл = Истина;
				КонецЕсли;
			КонецЕсли;
			
			Если ПозицияПоследнегоУл > 0 Тогда
				ПодстрокаПослеУл = СокрЛП(Сред(Результат, ПозицияПоследнегоУл + 5));
				// Если после </ul> пусто или только <br>, значит это последний закрывающий тег
				Если ПустаяСтрока(ПодстрокаПослеУл) ИЛИ ПодстрокаПослеУл = "<br>" Тогда
					ПредыдущийЗаканчиваетсяУл = Истина;
				КонецЕсли;
			КонецЕсли;
			
			// Если оба токена - списки одного типа, объединяем их
			Если (ТекущийНачинаетсяСОл И ПредыдущийЗаканчиваетсяОл) ИЛИ (ТекущийНачинаетсяСУл И ПредыдущийЗаканчиваетсяУл) Тогда
				// Находим последнее вхождение закрывающего тега
				ПозицияПоследнегоОл = СтрНайти(Результат, "</ol>", НаправлениеПоиска.СКонца);
				ПозицияПоследнегоУл = СтрНайти(Результат, "</ul>", НаправлениеПоиска.СКонца);
				
				// Используем простую замену: удаляем последнее </ol> или </ul> и добавляем содержимое
				Если ТекущийНачинаетсяСОл И ПредыдущийЗаканчиваетсяОл И ПозицияПоследнегоОл > 0 Тогда
					// Проверяем, есть ли <br> перед </ol>
					Если ПозицияПоследнегоОл > 4 И Сред(Результат, ПозицияПоследнегоОл - 4, 4) = "<br>" Тогда
						Результат = Лев(Результат, ПозицияПоследнегоОл - 5) + Сред(Результат, ПозицияПоследнегоОл + 5);
					Иначе
						Результат = Лев(Результат, ПозицияПоследнегоОл - 1) + Сред(Результат, ПозицияПоследнегоОл + 5);
					КонецЕсли;
					// Удаляем открывающий тег "<ol style='...'>" из текущего блока
					ПозицияОткрытияОл = СтрНайти(БлокHTML, "<ol");
					Если ПозицияОткрытияОл > 0 Тогда
						ПодстрокаПослеОткрытия = Сред(БлокHTML, ПозицияОткрытияОл);
						ПозицияЗакрытияТега = СтрНайти(ПодстрокаПослеОткрытия, ">");
						Если ПозицияЗакрытияТега > 0 Тогда
							БлокHTML = Лев(БлокHTML, ПозицияОткрытияОл - 1) + Сред(БлокHTML, ПозицияОткрытияОл + ПозицияЗакрытияТега);
						КонецЕсли;
					КонецЕсли;
					Результат = Результат + БлокHTML + "</ol>";
				ИначеЕсли ТекущийНачинаетсяСУл И ПредыдущийЗаканчиваетсяУл И ПозицияПоследнегоУл > 0 Тогда
					// Проверяем, есть ли <br> перед </ul>
					Если ПозицияПоследнегоУл > 4 И Сред(Результат, ПозицияПоследнегоУл - 4, 4) = "<br>" Тогда
						Результат = Лев(Результат, ПозицияПоследнегоУл - 5) + Сред(Результат, ПозицияПоследнегоУл + 5);
					Иначе
						Результат = Лев(Результат, ПозицияПоследнегоУл - 1) + Сред(Результат, ПозицияПоследнегоУл + 5);
					КонецЕсли;
					// Удаляем открывающий тег "<ul style='...'>" из текущего блока
					ПозицияОткрытияУл = СтрНайти(БлокHTML, "<ul");
					Если ПозицияОткрытияУл > 0 Тогда
						ПодстрокаПослеОткрытия = Сред(БлокHTML, ПозицияОткрытияУл);
						ПозицияЗакрытияТега = СтрНайти(ПодстрокаПослеОткрытия, ">");
						Если ПозицияЗакрытияТега > 0 Тогда
							БлокHTML = Лев(БлокHTML, ПозицияОткрытияУл - 1) + Сред(БлокHTML, ПозицияОткрытияУл + ПозицияЗакрытияТега);
						КонецЕсли;
					КонецЕсли;
					Результат = Результат + БлокHTML + "</ul>";
				КонецЕсли;
			Иначе
				Результат = Результат + "<br>" + БлокHTML;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция МД_РендерТокен(Токен)
	
	Тип = Токен.Тип;
	ДопИнфо = МД_ПолучитьДопИнфоТокена(Токен);
	
	Если Тип = "heading" Тогда
		Уровень = МД_ПолучитьЗначениеДопИнфо(ДопИнфо, "Уровень", 1);
		Если Уровень < 1 Тогда Уровень = 1; КонецЕсли;
		Если Уровень > 6 Тогда Уровень = 6; КонецЕсли;
		
		СтилиЗаголовков = Новый Массив;
		СтилиЗаголовков.Добавить("margin:15px 0 8px 0;font-size:1.5em;font-weight:600;");
		СтилиЗаголовков.Добавить("margin:12px 0 6px 0;font-size:1.3em;font-weight:600;");
		СтилиЗаголовков.Добавить("margin:10px 0 5px 0;font-size:1.1em;font-weight:600;");
		СтилиЗаголовков.Добавить("margin:8px 0 4px 0;font-size:1.05em;font-weight:600;");
		СтилиЗаголовков.Добавить("margin:8px 0 4px 0;font-size:1.0em;font-weight:600;");
		СтилиЗаголовков.Добавить("margin:8px 0 4px 0;font-size:0.95em;font-weight:600;");
		
		ИндексСтиля = Уровень - 1;
		Текст = МД_ОтформатироватьInline(Токен.Текст);
		Возврат "<h" + Строка(Уровень) + " style='" + СтилиЗаголовков[ИндексСтиля] + "'>" + Текст + "</h" + Строка(Уровень) + ">";
	КонецЕсли;
	
	Если Тип = "paragraph" Тогда
		Текст = МД_ОтформатироватьInline(Токен.Текст);
		Если ПустаяСтрока(Текст) Тогда
			Возврат "";
		КонецЕсли;
		Возврат "<p style='margin:6px 0;'>" + Текст + "</p>";
	КонецЕсли;
	
	Если Тип = "list" Тогда
		ТипСписка = МД_ПолучитьЗначениеДопИнфо(ДопИнфо, "Тип", "ul");
		Если ТипСписка <> "ol" Тогда
			ТипСписка = "ul";
		КонецЕсли;
		Тег = "<ul style='margin:5px 0;padding-left:20px;'>";
		Закрывающий = "</ul>";
		Если ТипСписка = "ol" Тогда
			Тег = "<ol style='margin:5px 0;padding-left:20px;'>";
			Закрывающий = "</ol>";
		КонецЕсли;
		
		HTMLСписка = Тег;
		Для Каждого Элемент Из Токен.Дочерние Цикл
			HTMLСписка = HTMLСписка + "<li>" + МД_ОтформатироватьInline(Элемент) + "</li>";
		КонецЦикла;
		HTMLСписка = HTMLСписка + Закрывающий;
		Возврат HTMLСписка;
	КонецЕсли;
	
	Если Тип = "codeblock" Тогда
		КодHTML = ЭкранироватьHTML(Токен.Текст);
		Язык = МД_ПолучитьЗначениеДопИнфо(ДопИнфо, "Язык", "");
		Класс = "";
		Если ЗначениеЗаполнено(Язык) Тогда
			Класс = " class='language-" + Язык + "'";
		КонецЕсли;
		Возврат "<pre><code" + Класс + ">" + КодHTML + "</code></pre>";
	КонецЕсли;
	
	Если Тип = "table" Тогда
		Заголовки = МД_ПолучитьЗначениеДопИнфо(ДопИнфо, "Заголовки", Неопределено);
		СтрокиТаблицы = МД_ПолучитьЗначениеДопИнфо(ДопИнфо, "Строки", Неопределено);
		Выравнивания = МД_ПолучитьЗначениеДопИнфо(ДопИнфо, "Выравнивания", Неопределено);
		
		Если Заголовки = Неопределено Тогда
			Возврат "";
		КонецЕсли;
		
		HTML = "<table style='border-collapse: collapse; width: 100%; margin: 10px 0; border: 1px solid #d7dde5;'>";
		HTML = HTML + "<thead><tr>";
		ИндексКолонки = 0;
		Для Каждого Ячейка Из Заголовки Цикл
			СтильВыравнивания = МД_ПолучитьСтильВыравнивания(Выравнивания, ИндексКолонки);
			HTML = HTML + "<th style='border: 1px solid #d7dde5; padding: 8px 12px; " + СтильВыравнивания + "background-color: #f8f9fa; font-weight: 600;'>" + МД_ОтформатироватьInline(СокрЛП(Ячейка)) + "</th>";
			ИндексКолонки = ИндексКолонки + 1;
		КонецЦикла;
		HTML = HTML + "</tr></thead>";
		
		HTML = HTML + "<tbody>";
		Для Каждого СтрокаТаблицы Из СтрокиТаблицы Цикл
			HTML = HTML + "<tr>";
			ИндексКолонки = 0;
			Для Каждого Ячейка Из СтрокаТаблицы Цикл
				СтильВыравнивания = МД_ПолучитьСтильВыравнивания(Выравнивания, ИндексКолонки);
				HTML = HTML + "<td style='border: 1px solid #d7dde5; padding: 8px 12px; " + СтильВыравнивания + "'>" + МД_ОтформатироватьInline(СокрЛП(Ячейка)) + "</td>";
				ИндексКолонки = ИндексКолонки + 1;
			КонецЦикла;
			HTML = HTML + "</tr>";
		КонецЦикла;
		HTML = HTML + "</tbody></table>";
		
		Возврат HTML;
	КонецЕсли;
	
	Если Тип = "blockquote" Тогда
		Текст = МД_ОтформатироватьInline(Токен.Текст);
		Возврат "<blockquote style='margin:8px 0;padding-left:16px;border-left:3px solid #d1d5db;color:#374151;'>" + Текст + "</blockquote>";
	КонецЕсли;
	
	Если Тип = "math_block" Тогда
		Возврат "<div class='md-math-block' style='margin:10px 0;padding:8px 12px;background:#f8fafc;border-radius:6px;font-family:""Consolas"",""Courier New"",monospace;'>" + ЭкранироватьHTML(Токен.Текст) + "</div>";
	КонецЕсли;
	
	Если Тип = "rawhtml" Тогда
		Возврат Токен.Текст;
	КонецЕсли;
	
	Если Тип = "hr" Тогда
		Возврат "<hr style='border:0;border-top:1px solid #ddd;margin:10px 0;'>";
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

Функция МД_ПолучитьДопИнфоТокена(Знач Токен)
	
	Если ТипЗнч(Токен) <> Тип("Структура") Тогда
		Возврат Новый Структура;
	КонецЕсли;
	
	Если Токен.Свойство("Дополнительно") Тогда
		ДопИнфо = Токен.Дополнительно;
		Если ТипЗнч(ДопИнфо) = Тип("Структура") Тогда
			Возврат ДопИнфо;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Новый Структура;
	
КонецФункции

Функция МД_ПолучитьЗначениеДопИнфо(ДопИнфо, Имя, ЗначениеПоУмолчанию)
	
	Если ТипЗнч(ДопИнфо) <> Тип("Структура") Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
МестноеЗначение = Неопределено;
Если ДопИнфо.Свойство(Имя, МестноеЗначение) Тогда
	Возврат МестноеЗначение;
	КонецЕсли;
	
	Возврат ЗначениеПоУмолчанию;
	
КонецФункции

Функция МД_ОтформатироватьInline(Знач Текст)
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат "";
	КонецЕсли;
	
	ЛокальныйТекст = Текст;
	InlineКод = Новый Соответствие;
	ЛокальныйТекст = СохранитьInlineКод(ЛокальныйТекст, InlineКод);
	
	HTMLТеги = Новый Соответствие;
	ЛокальныйТекст = СохранитьHTMLТеги(ЛокальныйТекст, HTMLТеги);
	
	InlineМатематика = Новый Соответствие;
	ЛокальныйТекст = МД_СохранитьInlineМатематику(ЛокальныйТекст, InlineМатематика);
	
	ЛокальныйТекст = ЭкранироватьHTML(ЛокальныйТекст);
	ЛокальныйТекст = МД_ВернутьЭкранированныеПлейсхолдеры(ЛокальныйТекст, InlineКод);
	ЛокальныйТекст = МД_ВернутьЭкранированныеПлейсхолдеры(ЛокальныйТекст, HTMLТеги);
	ЛокальныйТекст = МД_ВернутьЭкранированныеПлейсхолдеры(ЛокальныйТекст, InlineМатематика);
	ЛокальныйТекст = ОбработатьМаркдаунИзображения(ЛокальныйТекст);
	ЛокальныйТекст = ОбработатьМаркдаунСсылки(ЛокальныйТекст);
	ЛокальныйТекст = МД_ОбработатьСсылкиСоСносками(ЛокальныйТекст);
	ЛокальныйТекст = МД_УдалитьСсылкиНаДокументы(ЛокальныйТекст);
	ЛокальныйТекст = МД_ОбработатьБлочнуюМатематику(ЛокальныйТекст);
	ЛокальныйТекст = ПрименитьПравилаПреобразованийMarkdown(ЛокальныйТекст);
	ЛокальныйТекст = ЗаменитьЗачеркнутыйТекст(ЛокальныйТекст);
	
	ЛокальныйТекст = ВосстановитьHTMLТеги(ЛокальныйТекст, HTMLТеги);
	ЛокальныйТекст = ВосстановитьInlineКод(ЛокальныйТекст, InlineКод);
	ЛокальныйТекст = МД_ВосстановитьInlineМатематику(ЛокальныйТекст, InlineМатематика);
	ЛокальныйТекст = СтрЗаменить(ЛокальныйТекст, Символы.ПС, "<br>");
	
	Возврат ЛокальныйТекст;
	
КонецФункции

Функция МД_ВернутьЭкранированныеПлейсхолдеры(Знач Текст, СоответствиеПлейсхолдеров)
	
	Если СоответствиеПлейсхолдеров = Неопределено Тогда
		Возврат Текст;
	КонецЕсли;
	
	Результат = Текст;
	Для Каждого Элемент Из СоответствиеПлейсхолдеров Цикл
		Плейсхолдер = Элемент.Ключ;
		ЭкранированныйПлейсхолдер = ЭкранироватьHTML(Плейсхолдер);
		Если СтрНайти(Результат, ЭкранированныйПлейсхолдер) > 0 Тогда
			Результат = СтрЗаменить(Результат, ЭкранированныйПлейсхолдер, Плейсхолдер);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция МД_СохранитьInlineМатематику(Знач Текст, InlineМатематика)
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат Текст;
	КонецЕсли;
	
	Результат = Текст;
	Индекс = 1;
	Счетчик = 0;
	
	Пока Истина Цикл
		ПодстрокаСНачала = Сред(Результат, Индекс);
		ПозицияОткрытияОтносительно = СтрНайти(ПодстрокаСНачала, "$");
		Если ПозицияОткрытияОтносительно = 0 Тогда
			Прервать;
		КонецЕсли;
		ПозицияОткрытия = Индекс + ПозицияОткрытияОтносительно - 1;
		
		Если ПозицияОткрытия > 1 И Сред(Результат, ПозицияОткрытия - 1, 1) = "\" Тогда
			Индекс = ПозицияОткрытия + 1;
			Продолжить;
		КонецЕсли;
		
		// Игнорируем блоки "$$"
		Если Сред(Результат, ПозицияОткрытия, 2) = "$$" Тогда
			Индекс = ПозицияОткрытия + 2;
			Продолжить;
		КонецЕсли;
		
		ПодстрокаПослеОткрытия = Сред(Результат, ПозицияОткрытия + 1);
		ПозицияЗакрытияОтносительно = СтрНайти(ПодстрокаПослеОткрытия, "$");
		Если ПозицияЗакрытияОтносительно = 0 Тогда
			Прервать;
		КонецЕсли;
		ПозицияЗакрытия = ПозицияОткрытия + ПозицияЗакрытияОтносительно;
		
		// Игнорируем блоковые "$$"
		Если Сред(Результат, ПозицияЗакрытия, 2) = "$$" Тогда
			Индекс = ПозицияЗакрытия + 2;
			Продолжить;
		КонецЕсли;
		
		Контент = Сред(Результат, ПозицияОткрытия + 1, ПозицияЗакрытия - ПозицияОткрытия - 1);
		Плейсхолдер = "<<MD_MATH_INLINE_" + Формат(Счетчик, "ЧГ=") + ">>";
		InlineМатематика.Вставить(Плейсхолдер, Контент);
		
		Результат = Лев(Результат, ПозицияОткрытия - 1) + Плейсхолдер + Сред(Результат, ПозицияЗакрытия + 1);
		Индекс = ПозицияОткрытия + СтрДлина(Плейсхолдер);
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция МД_ВосстановитьInlineМатематику(Знач Текст, InlineМатематика)
	
	Если InlineМатематика = Неопределено Тогда
		Возврат Текст;
	КонецЕсли;
	
	Результат = Текст;
	Для Каждого Элемент Из InlineМатематика Цикл
		Плейсхолдер = Элемент.Ключ;
		Контент = Элемент.Значение;
		HTML = "<span class='md-math-inline' style='font-family:""Consolas"",""Courier New"",monospace;background:#eef2ff;padding:1px 4px;border-radius:4px;'>" + ЭкранироватьHTML(Контент) + "</span>";
		Результат = СтрЗаменить(Результат, Плейсхолдер, HTML);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция МД_ОбработатьБлочнуюМатематику(Знач Текст)
	
	Если СтрНайти(Текст, "$$") = 0 Тогда
		Возврат Текст;
	КонецЕсли;
	
	Строки = СтрРазделить(Текст, Символы.ПС, Ложь);
	Если Строки = Неопределено Тогда
		Возврат Текст;
	КонецЕсли;
	
	Результат = Новый Массив;
	Всего = Строки.ВГраница();
	Индекс = 0;
	
	Пока Индекс <= Всего Цикл
		Текущая = Строки[Индекс];
		Обрезанная = СокрЛП(Текущая);
		
		Если СтрНачинаетсяС(Обрезанная, "$$") Тогда
			Содержимое = Новый Массив;
			ЕстьЗакрытие = Ложь;
			
			// Проверяем, находится ли закрытие на той же строке
			Если СтрДлина(Обрезанная) > 2 И СтрЗаканчиваетсяНа(Обрезанная, "$$") И СтрДлина(Обрезанная) > 4 Тогда
				Содержимое.Добавить(Сред(Обрезанная, 3, СтрДлина(Обрезанная) - 4));
				ЕстьЗакрытие = Истина;
				Индекс = Индекс + 1;
			Иначе
				Индекс = Индекс + 1;
				Пока Индекс <= Всего Цикл
					СтрокаФормулы = Строки[Индекс];
					ОбрезаннаяФормула = СокрЛП(СтрокаФормулы);
					
					Если СтрНачинаетсяС(ОбрезаннаяФормула, "$$") Тогда
						Если СтрДлина(ОбрезаннаяФормула) > 2 Тогда
							Содержимое.Добавить(Сред(ОбрезаннаяФормула, 3));
						КонецЕсли;
						ЕстьЗакрытие = Истина;
						Индекс = Индекс + 1;
						Прервать;
					ИначеЕсли СтрЗаканчиваетсяНа(ОбрезаннаяФормула, "$$") Тогда
						Если СтрДлина(ОбрезаннаяФормула) > 2 Тогда
							Содержимое.Добавить(Лев(ОбрезаннаяФормула, СтрДлина(ОбрезаннаяФормула) - 2));
						КонецЕсли;
						ЕстьЗакрытие = Истина;
						Индекс = Индекс + 1;
						Прервать;
					Иначе
						Содержимое.Добавить(СтрокаФормулы);
						Индекс = Индекс + 1;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			
			Формула = СоединитьСтроки(Содержимое, Символы.ПС);
			HTMLФормулы = "<div class='md-math-block' style='margin:10px 0;padding:8px 12px;background:#f8fafc;border-radius:6px;font-family:""Consolas"",""Courier New"",monospace;'>" + ЭкранироватьHTML(Формула) + "</div>";
			Результат.Добавить(HTMLФормулы);
			
			Если Не ЕстьЗакрытие Тогда
				Продолжить;
			КонецЕсли;
			
			Продолжить;
		КонецЕсли;
		
		Результат.Добавить(Текущая);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат СоединитьСтроки(Результат, Символы.ПС);
	
КонецФункции

Функция МД_ИзвлечьОпределенияСносок(Знач Текст)
	
	Строки = СтрРазделить(Текст, Символы.ПС, Ложь);
	Если Строки = Неопределено Тогда
		Возврат Новый Структура("Текст", Текст, "Сноски", Новый Соответствие);
	КонецЕсли;
	
	Сноски = Новый Соответствие;
	НовыеСтроки = Новый Массив;
	
	Для Каждого Строка Из Строки Цикл
		Обрезанная = СокрЛП(Строка);
		Если СтрНачинаетсяС(Обрезанная, "[") Тогда
			ПозицияЗакрытия = СтрНайти(Обрезанная, "]:");
			Если ПозицияЗакрытия > 1 Тогда
				ИмяСноски = Сред(Обрезанная, 2, ПозицияЗакрытия - 2);
				ЗначениеСноски = СокрЛП(Сред(Обрезанная, ПозицияЗакрытия + 2));
				Если ЗначениеЗаполнено(ИмяСноски) И ЗначениеЗаполнено(ЗначениеСноски) Тогда
					Ключ = ВРег(ИмяСноски);
					Сноски.Вставить(Ключ, ЗначениеСноски);
					Продолжить;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		НовыеСтроки.Добавить(Строка);
	КонецЦикла;
	
	Возврат Новый Структура("Текст", СоединитьСтроки(НовыеСтроки, Символы.ПС), "Сноски", Сноски);
	
КонецФункции

Функция МД_ОбработатьСсылкиСоСносками(Знач Текст)
	
	Если МД_ОпределенияСносок = Неопределено ИЛИ МД_ОпределенияСносок.Количество() = 0 Тогда
		Возврат Текст;
	КонецЕсли;
	
	Результат = Текст;
	НачальнаяПозиция = 1;
	Счетчик = 0;
	Максимум = 1000;
	
	Пока Счетчик < Максимум Цикл
		ПодстрокаПослеНачала = Сред(Результат, НачальнаяПозиция);
		ПозицияОткрытияОтносительно = СтрНайти(ПодстрокаПослеНачала, "[");
		Если ПозицияОткрытияОтносительно = 0 Тогда
			Прервать;
		КонецЕсли;
		ПозицияОткрытия = НачальнаяПозиция + ПозицияОткрытияОтносительно - 1;
		
		Если ПозицияОткрытия > 1 И Сред(Результат, ПозицияОткрытия - 1, 1) = "!" Тогда
			НачальнаяПозиция = ПозицияОткрытия + 1;
			Продолжить;
		КонецЕсли;
		
		ПодстрокаПослеТекста = Сред(Результат, ПозицияОткрытия + 1);
		ПозицияЗакрытияОтносительно = СтрНайти(ПодстрокаПослеТекста, "]");
		Если ПозицияЗакрытияОтносительно = 0 Тогда
			Прервать;
		КонецЕсли;
		ПозицияЗакрытия = ПозицияОткрытия + ПозицияЗакрытияОтносительно;
		
		Если ПозицияЗакрытия >= СтрДлина(Результат) Тогда
			Прервать;
		КонецЕсли;
		
		Если Сред(Результат, ПозицияЗакрытия + 1, 1) <> "[" Тогда
			НачальнаяПозиция = ПозицияЗакрытия + 1;
			Продолжить;
		КонецЕсли;
		
		ПодстрокаПослеОпределения = Сред(Результат, ПозицияЗакрытия + 2);
		ПозицияЗакрытияОпределенияОтносительно = СтрНайти(ПодстрокаПослеОпределения, "]");
		Если ПозицияЗакрытияОпределенияОтносительно = 0 Тогда
			Прервать;
		КонецЕсли;
		ПозицияЗакрытияОпределения = ПозицияЗакрытия + 1 + ПозицияЗакрытияОпределенияОтносительно;
		
		ТекстСсылки = Сред(Результат, ПозицияОткрытия + 1, ПозицияЗакрытия - ПозицияОткрытия - 1);
		Идентификатор = Сред(Результат, ПозицияЗакрытия + 2, ПозицияЗакрытияОпределения - ПозицияЗакрытия - 2);
		
		Если Не ЗначениеЗаполнено(Идентификатор) Тогда
			НачальнаяПозиция = ПозицияЗакрытияОпределения + 1;
			Продолжить;
		КонецЕсли;
		
		Ключ = ВРег(СокрЛП(Идентификатор));
		Если Не МД_ОпределенияСносок.Свойство(Ключ) Тогда
			НачальнаяПозиция = ПозицияЗакрытияОпределения + 1;
			Продолжить;
		КонецЕсли;
		
		URL = МД_ОпределенияСносок[Ключ];
		HTML = "<a href=""" + URL + """>" + ТекстСсылки + "</a>";
		
		До = Лев(Результат, ПозицияОткрытия - 1);
		После = Сред(Результат, ПозицияЗакрытияОпределения + 1);
		Результат = До + HTML + После;
		НачальнаяПозиция = СтрДлина(До) + СтрДлина(HTML) + 1;
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

Функция МД_УдалитьСсылкиНаДокументы(Знач Текст)
	
	// Удаляем ссылки вида [[НомерДокумента]]()
	Если ПустаяСтрока(Текст) Тогда
		Возврат Текст;
	КонецЕсли;
	
	Результат = Текст;
	НачальнаяПозиция = 1;
	Счетчик = 0;
	Максимум = 1000;
	
	Пока Счетчик < Максимум Цикл
		ПодстрокаПослеНачала = Сред(Результат, НачальнаяПозиция);
		ПозицияОткрытияОтносительно = СтрНайти(ПодстрокаПослеНачала, "[[");
		Если ПозицияОткрытияОтносительно = 0 Тогда
			Прервать;
		КонецЕсли;
		ПозицияОткрытия = НачальнаяПозиция + ПозицияОткрытияОтносительно - 1;
		
		ПодстрокаПослеОткрытия = Сред(Результат, ПозицияОткрытия + 2);
		ПозицияЗакрытияОтносительно = СтрНайти(ПодстрокаПослеОткрытия, "]]");
		Если ПозицияЗакрытияОтносительно = 0 Тогда
			Прервать;
		КонецЕсли;
		ПозицияЗакрытия = ПозицияОткрытия + 2 + ПозицияЗакрытияОтносительно - 1;
		
		// Проверяем, что после ]] идет ()
		ПодстрокаПослеЗакрытия = Сред(Результат, ПозицияЗакрытия + 2);
		Если СтрНачинаетсяС(ПодстрокаПослеЗакрытия, "()") Тогда
			// Удаляем всю ссылку [[НомерДокумента]]()
			До = Лев(Результат, ПозицияОткрытия - 1);
			После = Сред(Результат, ПозицияЗакрытия + 4); // 2 для ]] + 2 для ()
			Результат = До + После;
			НачальнаяПозиция = ПозицияОткрытия;
		Иначе
			НачальнаяПозиция = ПозицияОткрытия + 2;
		КонецЕсли;
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция МД_ОбъединитьПоследовательныеСписки(Знач HTML)
	
	Если ПустаяСтрока(HTML) Тогда
		Возврат HTML;
	КонецЕсли;
	
	Результат = HTML;
	
	// Объединяем последовательные <ol> списки
	// Ищем паттерн: </ol><ol или </ol><br><ol
	Позиция = 1;
	Пока Истина Цикл
		ПодстрокаДляПоиска = Сред(Результат, Позиция);
		ПозицияОлОтносительно = СтрНайти(ПодстрокаДляПоиска, "</ol>");
		Если ПозицияОлОтносительно = 0 Тогда
			Прервать;
		КонецЕсли;
		ПозицияОл = Позиция + ПозицияОлОтносительно - 1;
		
		ПодстрокаПослеОл = Сред(Результат, ПозицияОл + 5);
		ПодстрокаПослеОл = СокрЛП(ПодстрокаПослеОл);
		
		// Проверяем, начинается ли следующий блок с <ol
		Если СтрНачинаетсяС(ПодстрокаПослеОл, "<ol") Тогда
			// Удаляем </ol>
			Результат = Лев(Результат, ПозицияОл - 1) + Сред(Результат, ПозицияОл + 5);
			// Удаляем открывающий тег <ol style='...'> из следующего блока (он теперь находится сразу после удаленного </ol>)
			ПозицияОткрытияОл = ПозицияОл;
			ПодстрокаПослеОткрытия = Сред(Результат, ПозицияОткрытияОл);
			ПозицияЗакрытияТега = СтрНайти(ПодстрокаПослеОткрытия, ">");
			Если ПозицияЗакрытияТега > 0 Тогда
				Результат = Лев(Результат, ПозицияОткрытияОл - 1) + Сред(Результат, ПозицияОткрытияОл + ПозицияЗакрытияТега);
			КонецЕсли;
			Позиция = ПозицияОл;
		ИначеЕсли СтрНачинаетсяС(ПодстрокаПослеОл, "<br>") Тогда
			ПодстрокаПослеБр = СокрЛП(Сред(ПодстрокаПослеОл, 5));
			Если СтрНачинаетсяС(ПодстрокаПослеБр, "<ol") Тогда
				// Удаляем </ol><br>
				Результат = Лев(Результат, ПозицияОл - 1) + Сред(Результат, ПозицияОл + 9); // 5 для </ol> + 4 для <br>
				// Удаляем открывающий тег <ol style='...'> из следующего блока (он теперь находится сразу после удаленного </ol><br>)
				ПозицияОткрытияОл = ПозицияОл;
				ПодстрокаПослеОткрытия = Сред(Результат, ПозицияОткрытияОл);
				ПозицияЗакрытияТега = СтрНайти(ПодстрокаПослеОткрытия, ">");
				Если ПозицияЗакрытияТега > 0 Тогда
					Результат = Лев(Результат, ПозицияОткрытияОл - 1) + Сред(Результат, ПозицияОткрытияОл + ПозицияЗакрытияТега);
				КонецЕсли;
				Позиция = ПозицияОл;
			Иначе
				Позиция = ПозицияОл + 5;
			КонецЕсли;
		Иначе
			Позиция = ПозицияОл + 5;
		КонецЕсли;
	КонецЦикла;
	
	// Аналогично для <ul> списков
	Позиция = 1;
	Пока Истина Цикл
		ПодстрокаДляПоиска = Сред(Результат, Позиция);
		ПозицияУлОтносительно = СтрНайти(ПодстрокаДляПоиска, "</ul>");
		Если ПозицияУлОтносительно = 0 Тогда
			Прервать;
		КонецЕсли;
		ПозицияУл = Позиция + ПозицияУлОтносительно - 1;
		
		ПодстрокаПослеУл = Сред(Результат, ПозицияУл + 5);
		ПодстрокаПослеУл = СокрЛП(ПодстрокаПослеУл);
		
		// Проверяем, начинается ли следующий блок с <ul
		Если СтрНачинаетсяС(ПодстрокаПослеУл, "<ul") Тогда
			// Удаляем </ul>
			Результат = Лев(Результат, ПозицияУл - 1) + Сред(Результат, ПозицияУл + 5);
			// Удаляем открывающий тег <ul style='...'> из следующего блока (он теперь находится сразу после удаленного </ul>)
			ПозицияОткрытияУл = ПозицияУл;
			ПодстрокаПослеОткрытия = Сред(Результат, ПозицияОткрытияУл);
			ПозицияЗакрытияТега = СтрНайти(ПодстрокаПослеОткрытия, ">");
			Если ПозицияЗакрытияТега > 0 Тогда
				Результат = Лев(Результат, ПозицияОткрытияУл - 1) + Сред(Результат, ПозицияОткрытияУл + ПозицияЗакрытияТега);
			КонецЕсли;
			Позиция = ПозицияУл;
		ИначеЕсли СтрНачинаетсяС(ПодстрокаПослеУл, "<br>") Тогда
			ПодстрокаПослеБр = СокрЛП(Сред(ПодстрокаПослеУл, 5));
			Если СтрНачинаетсяС(ПодстрокаПослеБр, "<ul") Тогда
				// Удаляем </ul><br>
				Результат = Лев(Результат, ПозицияУл - 1) + Сред(Результат, ПозицияУл + 9); // 5 для </ul> + 4 для <br>
				// Удаляем открывающий тег <ul style='...'> из следующего блока (он теперь находится сразу после удаленного </ul><br>)
				ПозицияОткрытияУл = ПозицияУл;
				ПодстрокаПослеОткрытия = Сред(Результат, ПозицияОткрытияУл);
				ПозицияЗакрытияТега = СтрНайти(ПодстрокаПослеОткрытия, ">");
				Если ПозицияЗакрытияТега > 0 Тогда
					Результат = Лев(Результат, ПозицияОткрытияУл - 1) + Сред(Результат, ПозицияОткрытияУл + ПозицияЗакрытияТега);
				КонецЕсли;
				Позиция = ПозицияУл;
			Иначе
				Позиция = ПозицияУл + 5;
			КонецЕсли;
		Иначе
			Позиция = ПозицияУл + 5;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция СохранитьInlineКод(Знач Текст, InlineКод)
	
	Результат = Текст;
	МаксимальноПопыток = 1000;
	Счетчик = 0;
	ИндексКода = 0;
	
	Пока Счетчик < МаксимальноПопыток Цикл
		Позиция1 = СтрНайти(Результат, "`");
		Если Позиция1 = 0 Тогда
			Прервать;
		КонецЕсли;
		
		ПодстрокаПослеПервого = Сред(Результат, Позиция1 + 1);
		Позиция2Относительно = СтрНайти(ПодстрокаПослеПервого, "`");
		Если Позиция2Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		Позиция2 = Позиция1 + Позиция2Относительно;
		
		КодВнутри = Сред(Результат, Позиция1 + 1, Позиция2 - Позиция1 - 1);
		
		Плейсхолдер = "<<MD_INLINECODE_" + Формат(ИндексКода, "ЧГ=") + ">>";
		InlineКод.Вставить(Плейсхолдер, КодВнутри);
		
		Результат = Лев(Результат, Позиция1 - 1) + Плейсхолдер + Сред(Результат, Позиция2 + 1);
		ИндексКода = ИндексКода + 1;
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции


Функция ВосстановитьInlineКод(Знач Текст, InlineКод)
	
	Результат = Текст;
	
	Для Каждого Элемент Из InlineКод Цикл
		Плейсхолдер = Элемент.Ключ;
		ЗначениеКода = Элемент.Значение;
		HTMLКод = "<code>" + ЗначениеКода + "</code>";
		
		Если СтрНайти(Результат, Плейсхолдер) > 0 Тогда
			Результат = СтрЗаменить(Результат, Плейсхолдер, HTMLКод);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция СохранитьHTMLТеги(Знач Текст, HTMLТеги)
	
	Результат = Текст;
	МаксимальноПопыток = 100;
	Счетчик = 0;
	ИндексТега = 0;
	
	// Разрешенные HTML теги
	РазрешенныеТеги = Новый Массив;
	РазрешенныеТеги.Добавить("u");
	РазрешенныеТеги.Добавить("kbd");
	РазрешенныеТеги.Добавить("div");
	
	Для Каждого Тег Из РазрешенныеТеги Цикл
		Пока Счетчик < МаксимальноПопыток Цикл
			ОткрывающийТег = "<" + Тег + ">";
			ЗакрывающийТег = "</" + Тег + ">";
			
			Позиция1 = СтрНайти(Результат, ОткрывающийТег);
			Если Позиция1 = 0 Тогда
				Прервать;
			КонецЕсли;
			
			ПодстрокаПослеОткрытия = Сред(Результат, Позиция1 + СтрДлина(ОткрывающийТег));
			Позиция2Относительно = СтрНайти(ПодстрокаПослеОткрытия, ЗакрывающийТег);
			Если Позиция2Относительно = 0 Тогда
				Прервать;
			КонецЕсли;
			
			Позиция2 = Позиция1 + СтрДлина(ОткрывающийТег) + Позиция2Относительно - 1;
			
			СодержимоеТега = Сред(Результат, Позиция1, Позиция2 - Позиция1 + СтрДлина(ЗакрывающийТег));
			
			Плейсхолдер = "<<MD_HTMLTAG_" + Формат(ИндексТега, "ЧГ=") + ">>";
			HTMLТеги.Вставить(Плейсхолдер, СодержимоеТега);
			
			Результат = Лев(Результат, Позиция1 - 1) + Плейсхолдер + Сред(Результат, Позиция2 + СтрДлина(ЗакрывающийТег));
			ИндексТега = ИндексТега + 1;
			Счетчик = Счетчик + 1;
		КонецЦикла;
		Счетчик = 0;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ВосстановитьHTMLТеги(Знач Текст, HTMLТеги)
	
	Результат = Текст;
	
	Для Каждого Элемент Из HTMLТеги Цикл
		Плейсхолдер = Элемент.Ключ;
		ЗначениеТега = Элемент.Значение;
		Результат = СтрЗаменить(Результат, Плейсхолдер, ЗначениеТега);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции






Функция РазобратьСтрокуТаблицы(Знач Строка)
	
	Результат = Новый Массив;
	
	Если ПустаяСтрока(Строка) Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Убираем начальный и конечный |
	Если СтрНачинаетсяС(Строка, "|") Тогда
		Строка = Сред(Строка, 2);
	КонецЕсли;
	Если СтрЗаканчиваетсяНа(Строка, "|") Тогда
		Строка = Лев(Строка, СтрДлина(Строка) - 1);
	КонецЕсли;
	
	// Разделяем по |
	Части = СтрРазделить(Строка, "|", Ложь);
	Для Каждого Часть Из Части Цикл
		Результат.Добавить(Часть);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция СформироватьHTMLОшибки(Знач Сообщение) Экспорт

	ТекстОшибки = Строка(Сообщение);
	ТекстОшибки = СтрЗаменить(ТекстОшибки, "&", "&amp;");
	ТекстОшибки = СтрЗаменить(ТекстОшибки, "<", "&lt;");
	ТекстОшибки = СтрЗаменить(ТекстОшибки, ">", "&gt;");
	ТекстОшибки = СтрЗаменить(ТекстОшибки, """", "&quot;");
	ТекстОшибки = СтрЗаменить(ТекстОшибки, "'", "&#39;");

	Возврат СтрШаблон("<html><head><meta charset=""UTF-8""></head><body style=""margin:0;padding:12px 16px;background:#fff5f5;font-family:Segoe UI,Tahoma,Verdana,sans-serif;color:#d93025;""><div style=""border:1px solid #f5c2c7;background:#fff;box-shadow:0 1px 3px rgba(220,38,38,0.15);padding:14px;border-radius:8px;""><span style=""font-weight:600;display:block;margin-bottom:6px;"">Ошибка загрузки истории:</span><span style=""color:#7f1d1d;"">%1</span></div></body></html>", ТекстОшибки);

КонецФункции

Функция ДобавитьИндикаторПечати(Знач HTMLЧата, Знач ИмяАгента)
	
	Если ПустаяСтрока(HTMLЧата) Тогда
		Возврат HTMLЧата;
	КонецЕсли;
	
	Попытка
		Имя = Строка(ИмяАгента);
	Исключение
		Имя = "";
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(Имя) Тогда
		Имя = НСтр("ru='Агент'");
	КонецЕсли;
	
	Имя = ЭкранироватьHTML(Имя);
	
	ИндикаторHTML = СтрШаблон("<div class=""message typing-indicator""><div class=""message-text typing-text""><span>%1 печатает сообщение</span><span class=""typing-dot""></span><span class=""typing-dot""></span><span class=""typing-dot""></span></div></div>", Имя);
	
	ПозицияЯкоря = СтрНайти(HTMLЧата, "<div id=""chat-scroll-anchor""");
	Если ПозицияЯкоря > 0 Тогда
		ЛеваяЧасть = Лев(HTMLЧата, ПозицияЯкоря - 1);
		ПраваяЧасть = Сред(HTMLЧата, ПозицияЯкоря);
		Возврат ЛеваяЧасть + ИндикаторHTML + Символы.ПС + ПраваяЧасть;
	КонецЕсли;
	
	ПозицияКонтейнера = СтрНайти(HTMLЧата, "</div></body></html>");
	Если ПозицияКонтейнера > 0 Тогда
		ЛеваяЧасть = Лев(HTMLЧата, ПозицияКонтейнера - 1);
		ПраваяЧасть = Сред(HTMLЧата, ПозицияКонтейнера);
		Возврат ЛеваяЧасть + ИндикаторHTML + Символы.ПС + ПраваяЧасть;
	КонецЕсли;
	
	Возврат HTMLЧата + Символы.ПС + ИндикаторHTML;
	
КонецФункции

Функция СоединитьСтроки(Строки, Разделитель)
	Если ТипЗнч(Строки) <> Тип("Массив") Тогда
		Возврат "";
	КонецЕсли;
	Результат = "";
	Для Индекс = 0 По Строки.ВГраница() Цикл
		Если Индекс > 0 Тогда
			Результат = Результат + Разделитель;
		КонецЕсли;
		ТекущееЗначение = Строки[Индекс];
		Если Не ЗначениеЗаполнено(ТекущееЗначение) Тогда
			ТекущееЗначение = "";
		Иначе
			ТекущееЗначение = Строка(ТекущееЗначение);
		КонецЕсли;
		Результат = Результат + ТекущееЗначение;
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ЗаменитьЖирныйКурсивЧерезПодчеркивания(Знач Текст)
	
	Результат = Текст;
	МаксимальноПопыток = 1000;
	Счетчик = 0;
	
	Пока Счетчик < МаксимальноПопыток Цикл
		Позиция1 = СтрНайти(Результат, "___");
		Если Позиция1 = 0 Тогда
			Прервать;
		КонецЕсли;
		
		ПодстрокаПослеПервого = Сред(Результат, Позиция1 + 3);
		Позиция2Относительно = СтрНайти(ПодстрокаПослеПервого, "___");
		Если Позиция2Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Позиция2 = (Позиция1 + 3 - 1) + Позиция2Относительно;
		
		ТекстВнутри = Сред(Результат, Позиция1 + 3, Позиция2 - Позиция1 - 3);
		Результат = Лев(Результат, Позиция1 - 1) + "<strong><em>" + ТекстВнутри + "</em></strong>" + Сред(Результат, Позиция2 + 3);
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ЗаменитьЖирныйТекстЧерезЗвездочки(Знач Текст)
	
	Результат = Текст;
	МаксимальноПопыток = 1000;
	Счетчик = 0;
	
	Пока Счетчик < МаксимальноПопыток Цикл
		Позиция1 = СтрНайти(Результат, "**");
		Если Позиция1 = 0 Тогда
			Прервать;
		КонецЕсли;
		
		ПодстрокаПослеПервого = Сред(Результат, Позиция1 + 2);
		Позиция2Относительно = СтрНайти(ПодстрокаПослеПервого, "**");
		Если Позиция2Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		Позиция2 = (Позиция1 + 2 - 1) + Позиция2Относительно;
		
		ТекстВнутри = Сред(Результат, Позиция1 + 2, Позиция2 - Позиция1 - 2);
		Результат = Лев(Результат, Позиция1 - 1) + "<strong>" + ТекстВнутри + "</strong>" + Сред(Результат, Позиция2 + 2);
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ЗаменитьЖирныйТекстЧерезПодчеркивания(Знач Текст)
	
	Результат = Текст;
	МаксимальноПопыток = 1000;
	Счетчик = 0;
	НачальнаяПозицияПоиска = 1;
	
	Пока Счетчик < МаксимальноПопыток Цикл
		ПодстрокаДляПоиска = Сред(Результат, НачальнаяПозицияПоиска);
		Позиция1Относительно = СтрНайти(ПодстрокаДляПоиска, "__");
		Если Позиция1Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		Позиция1 = НачальнаяПозицияПоиска + Позиция1Относительно - 1;
		
		ПодстрокаПослеПервого = Сред(Результат, Позиция1 + 2);
		Позиция2Относительно = СтрНайти(ПодстрокаПослеПервого, "__");
		Если Позиция2Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		
		// Проверяем, что это не тройное подчеркивание (жирный курсив)
		Если Позиция2Относительно <= СтрДлина(ПодстрокаПослеПервого) И Сред(ПодстрокаПослеПервого, Позиция2Относительно + 1, 1) = "_" Тогда
			// Это тройное подчеркивание, пропускаем - ищем следующую позицию после тройного подчеркивания
			НачальнаяПозицияПоиска = Позиция1 + 3;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		Позиция2 = Позиция1 + Позиция2Относительно + 1;
		
		ТекстВнутри = Сред(Результат, Позиция1 + 2, Позиция2 - Позиция1 - 2);
		Результат = Лев(Результат, Позиция1 - 1) + "<strong>" + ТекстВнутри + "</strong>" + Сред(Результат, Позиция2 + 1);
		НачальнаяПозицияПоиска = Позиция1 + СтрДлина("<strong>" + ТекстВнутри + "</strong>");
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ЗаменитьКурсивныйТекст(Знач Текст)
	
	Результат = Текст;
	МаксимальноПопыток = 1000;
	Счетчик = 0;
	НачальнаяПозицияПоиска = 1;
	
	// Обрабатываем курсив через одинарные звездочки *текст*
	Пока Счетчик < МаксимальноПопыток Цикл
		ПодстрокаДляПоиска = Сред(Результат, НачальнаяПозицияПоиска);
		Позиция1Относительно = СтрНайти(ПодстрокаДляПоиска, "*");
		Если Позиция1Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		Позиция1 = НачальнаяПозицияПоиска + Позиция1Относительно - 1;
		
		// Проверяем, что это не двойная звездочка (жирный текст)
		Если Позиция1 < СтрДлина(Результат) И Сред(Результат, Позиция1 + 1, 1) = "*" Тогда
			// Это жирный текст, пропускаем - ищем следующую позицию после двойной звездочки
			НачальнаяПозицияПоиска = Позиция1 + 2;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		ПодстрокаПослеПервого = Сред(Результат, Позиция1 + 1);
		Позиция2Относительно = СтрНайти(ПодстрокаПослеПервого, "*");
		Если Позиция2Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		
		// Проверяем, что следующий символ после второй звездочки не звездочка
		Если Позиция2Относительно < СтрДлина(ПодстрокаПослеПервого) И Сред(ПодстрокаПослеПервого, Позиция2Относительно + 1, 1) = "*" Тогда
			// Это часть жирного текста, пропускаем
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		Позиция2 = Позиция1 + Позиция2Относительно;
		
		ТекстВнутри = Сред(Результат, Позиция1 + 1, Позиция2 - Позиция1 - 1);
		Результат = Лев(Результат, Позиция1 - 1) + "<em>" + ТекстВнутри + "</em>" + Сред(Результат, Позиция2 + 1);
		НачальнаяПозицияПоиска = Позиция1 + СтрДлина("<em>") + СтрДлина(ТекстВнутри) + СтрДлина("</em>");
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	// Обрабатываем курсив через подчеркивания _текст_
	Счетчик = 0;
	НачальнаяПозицияПоиска = 1;
	Пока Счетчик < МаксимальноПопыток Цикл
		ПодстрокаДляПоиска = Сред(Результат, НачальнаяПозицияПоиска);
		Позиция1Относительно = СтрНайти(ПодстрокаДляПоиска, "_");
		Если Позиция1Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		Позиция1 = НачальнаяПозицияПоиска + Позиция1Относительно - 1;
		
		// Проверяем, что это не двойное подчеркивание (жирный текст)
		Если Позиция1 < СтрДлина(Результат) И Сред(Результат, Позиция1 + 1, 1) = "_" Тогда
			// Это жирный текст, пропускаем - ищем следующую позицию после двойного подчеркивания
			НачальнаяПозицияПоиска = Позиция1 + 2;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		ПодстрокаПослеПервого = Сред(Результат, Позиция1 + 1);
		Позиция2Относительно = СтрНайти(ПодстрокаПослеПервого, "_");
		Если Позиция2Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		
		// Проверяем, что следующий символ после второго подчеркивания не подчеркивание
		Если Позиция2Относительно < СтрДлина(ПодстрокаПослеПервого) И Сред(ПодстрокаПослеПервого, Позиция2Относительно + 1, 1) = "_" Тогда
			// Это часть жирного текста, пропускаем
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		Позиция2 = Позиция1 + Позиция2Относительно;
		
		ТекстВнутри = Сред(Результат, Позиция1 + 1, Позиция2 - Позиция1 - 1);
		Результат = Лев(Результат, Позиция1 - 1) + "<em>" + ТекстВнутри + "</em>" + Сред(Результат, Позиция2 + 1);
		НачальнаяПозицияПоиска = Позиция1 + СтрДлина("<em>") + СтрДлина(ТекстВнутри) + СтрДлина("</em>");
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ЗаменитьЗачеркнутыйТекст(Знач Текст)
	
	Если СтрНайти(Текст, "~~") = 0 Тогда
		Возврат Текст;
	КонецЕсли;
	
	Результат = Текст;
	МаксимальноПопыток = 2000;
	Счетчик = 0;
	НачальнаяПозиция = 1;
	
	Пока Счетчик < МаксимальноПопыток Цикл
		
		ПодстрокаДляПоиска = Сред(Результат, НачальнаяПозиция);
		Позиция1Относительно = СтрНайти(ПодстрокаДляПоиска, "~~");
		Если Позиция1Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Позиция1 = НачальнаяПозиция + Позиция1Относительно - 1;
		
		ПодстрокаПослеПервого = Сред(Результат, Позиция1 + 2);
		Позиция2Относительно = СтрНайти(ПодстрокаПослеПервого, "~~");
		Если Позиция2Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Позиция2 = Позиция1 + 2 + Позиция2Относительно - 1;
		
		ТекстВнутри = Сред(Результат, Позиция1 + 2, Позиция2 - Позиция1 - 2);
		HTML = "<del>" + ТекстВнутри + "</del>";
		
		До = "";
		Если Позиция1 > 1 Тогда
			До = Лев(Результат, Позиция1 - 1);
		КонецЕсли;
		После = Сред(Результат, Позиция2 + 2);
		
		Результат = До + HTML + После;
		НачальнаяПозиция = СтрДлина(До) + СтрДлина(HTML) + 1;
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ОбработатьМаркдаунИзображения(Знач Текст)
	
	Результат = Текст;
	МаксимальноПопыток = 1000;
	Счетчик = 0;
	НачальнаяПозицияПоиска = 1;
	
	// Обрабатываем изображения вида ![alt](url) или ![alt](url "title")
	// ВАЖНО: Обрабатываем изображения ДО ссылок, так как они начинаются с !
	Пока Счетчик < МаксимальноПопыток Цикл
		ПодстрокаДляПоиска = Сред(Результат, НачальнаяПозицияПоиска);
		ПозицияВосклицательного = СтрНайти(ПодстрокаДляПоиска, "![");
		Если ПозицияВосклицательного = 0 Тогда
			Прервать;
		КонецЕсли;
		Позиция1 = НачальнаяПозицияПоиска + ПозицияВосклицательного - 1;
		
		// Проверяем, не является ли это частью плейсхолдера
		Если ЯвляетсяЧастьюПлейсхолдера(Результат, Позиция1) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		// Проверяем, не находится ли внутри HTML тега
		Если НаходитсяВнутриHTMLТега(Результат, Позиция1) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		ПодстрокаПослеСкобки = Сред(Результат, Позиция1 + 2); // +2 потому что "!["
		Позиция2Относительно = СтрНайти(ПодстрокаПослеСкобки, "]");
		Если Позиция2Относительно = 0 Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		AltТекст = Сред(ПодстрокаПослеСкобки, 1, Позиция2Относительно - 1);
		
		ПодстрокаПослеТекста = Сред(ПодстрокаПослеСкобки, Позиция2Относительно + 1);
		Если Не СтрНачинаетсяС(ПодстрокаПослеТекста, "(") Тогда
			// Это не изображение, пропускаем
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		ПодстрокаПослеСкобкиОткрытия = Сред(ПодстрокаПослеТекста, 2);
		Позиция3Относительно = СтрНайти(ПодстрокаПослеСкобкиОткрытия, ")");
		Если Позиция3Относительно = 0 Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		URLСTitle = Сред(ПодстрокаПослеСкобкиОткрытия, 1, Позиция3Относительно - 1);
		
		// Проверяем, есть ли title в кавычках
		URL = СокрЛП(URLСTitle);
		Title = "";
		ПозицияКавычек = СтрНайти(URLСTitle, """");
		Если ПозицияКавычек > 0 Тогда
			URL = СокрЛП(Лев(URLСTitle, ПозицияКавычек - 1));
			Title = Сред(URLСTitle, ПозицияКавычек + 1);
			Если СтрЗаканчиваетсяНа(Title, """") Тогда
				Title = Лев(Title, СтрДлина(Title) - 1);
			КонецЕсли;
			Title = СокрЛП(Title);
		КонецЕсли;
		
		Позиция2 = Позиция1 + 1 + Позиция2Относительно; // +1 для "!"
		Позиция3 = Позиция1 + 2 + Позиция2Относительно + 1 + Позиция3Относительно; // +2 для "!["
		
		Если Не ПустаяСтрока(Title) Тогда
			HTMLИзображение = "<img src=""" + URL + """ alt=""" + ЭкранироватьHTML(AltТекст) + """ title=""" + ЭкранироватьHTML(Title) + """>";
		Иначе
			HTMLИзображение = "<img src=""" + URL + """ alt=""" + ЭкранироватьHTML(AltТекст) + """>";
		КонецЕсли;
		
		Результат = Лев(Результат, Позиция1 - 1) + HTMLИзображение + Сред(Результат, Позиция3 + 1);
		НачальнаяПозицияПоиска = Позиция1 + СтрДлина(HTMLИзображение);
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ОбработатьМаркдаунСсылки(Знач Текст)
	
	Результат = Текст;
	МаксимальноПопыток = 1000;
	Счетчик = 0;
	НачальнаяПозицияПоиска = 1;
	
	// Обрабатываем ссылки вида [текст](url) или [текст](url "title")
	// ВАЖНО: Изображения уже обработаны, поэтому пропускаем ![]
	Пока Счетчик < МаксимальноПопыток Цикл
		ПодстрокаДляПоиска = Сред(Результат, НачальнаяПозицияПоиска);
		Позиция1Относительно = СтрНайти(ПодстрокаДляПоиска, "[");
		Если Позиция1Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		Позиция1 = НачальнаяПозицияПоиска + Позиция1Относительно - 1;
		
		// Пропускаем изображения (они уже обработаны)
		Если Позиция1 > 1 И Сред(Результат, Позиция1 - 1, 1) = "!" Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		// Проверяем, не является ли это частью плейсхолдера
		Если ЯвляетсяЧастьюПлейсхолдера(Результат, Позиция1) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		// Проверяем, не находится ли внутри HTML тега
		Если НаходитсяВнутриHTMLТега(Результат, Позиция1) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		ПодстрокаПослеСкобки = Сред(Результат, Позиция1 + 1);
		Позиция2Относительно = СтрНайти(ПодстрокаПослеСкобки, "]");
		Если Позиция2Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		
		ТекстСсылки = Сред(ПодстрокаПослеСкобки, 1, Позиция2Относительно - 1);
		
		ПодстрокаПослеТекста = Сред(ПодстрокаПослеСкобки, Позиция2Относительно + 1);
		Если Не СтрНачинаетсяС(ПодстрокаПослеТекста, "(") Тогда
			// Это не ссылка, пропускаем - ищем следующую позицию после закрывающей скобки
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		ПодстрокаПослеСкобкиОткрытия = Сред(ПодстрокаПослеТекста, 2);
		Позиция3Относительно = СтрНайти(ПодстрокаПослеСкобкиОткрытия, ")");
		Если Позиция3Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		
		URLСTitle = Сред(ПодстрокаПослеСкобкиОткрытия, 1, Позиция3Относительно - 1);
		
		// Проверяем, есть ли title в кавычках
		URL = СокрЛП(URLСTitle);
		Title = "";
		ПозицияКавычек = СтрНайти(URLСTitle, """");
		Если ПозицияКавычек > 0 Тогда
			URL = СокрЛП(Лев(URLСTitle, ПозицияКавычек - 1));
			Title = Сред(URLСTitle, ПозицияКавычек + 1);
			Если СтрЗаканчиваетсяНа(Title, """") Тогда
				Title = Лев(Title, СтрДлина(Title) - 1);
			КонецЕсли;
			Title = СокрЛП(Title);
		КонецЕсли;
		
		Позиция2 = Позиция1 + Позиция2Относительно;
		Позиция3 = Позиция1 + 1 + Позиция2Относительно + 1 + Позиция3Относительно;
		
		Если Не ПустаяСтрока(Title) Тогда
			HTMLСсылка = "<a href=""" + URL + """ title=""" + ЭкранироватьHTML(Title) + """>" + ТекстСсылки + "</a>";
		Иначе
			HTMLСсылка = "<a href=""" + URL + """>" + ТекстСсылки + "</a>";
		КонецЕсли;
		
		Результат = Лев(Результат, Позиция1 - 1) + HTMLСсылка + Сред(Результат, Позиция3 + 1);
		НачальнаяПозицияПоиска = Позиция1 + СтрДлина(HTMLСсылка);
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ОбработатьМаркдаунСписки(Знач Текст)
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат "";
	КонецЕсли;
	
	Строки = СтрРазделить(Текст, Символы.ПС, Ложь);
	Результат = "";
	
	// Массив для хранения открытых списков по уровням
	ОткрытыеСписки = Новый Массив;
	
	Для Индекс = 0 По Строки.ВГраница() Цикл
		Строка = Строки[Индекс];
		
		ИнфоСписка = РазобратьЭлементСписка(Строка);
		
		Если ИнфоСписка.ЭтоСписок Тогда
			
			ТекущийУровень = ИнфоСписка.УровеньВложенности;
			
			// Закрываем списки, которые находятся на более глубоких уровнях
			Пока ОткрытыеСписки.Количество() > ТекущийУровень Цикл
				ИндексСписка = ОткрытыеСписки.ВГраница();
				ТипЗакрываемогоСписка = ОткрытыеСписки[ИндексСписка];
				Если ТипЗакрываемогоСписка = "ul" Тогда
					Результат = Результат + "</ul>";
				Иначе
					Результат = Результат + "</ol>";
				КонецЕсли;
				ОткрытыеСписки.Удалить(ИндексСписка);
			КонецЦикла;
			
			// Открываем списки до нужного уровня
			Пока ОткрытыеСписки.Количество() < ТекущийУровень Цикл
				// Для вложенных уровней используем тип текущего списка
				ТипОткрываемогоСписка = ИнфоСписка.ТипСписка;
				
				Если ТипОткрываемогоСписка = "ul" Тогда
					Результат = Результат + "<ul style='margin:5px 0;padding-left:20px;'>";
				Иначе
					Результат = Результат + "<ol style='margin:5px 0;padding-left:20px;'>";
				КонецЕсли;
				ОткрытыеСписки.Добавить(ТипОткрываемогоСписка);
			КонецЦикла;
			
			// Если текущий уровень равен количеству открытых списков, проверяем тип
			Если ОткрытыеСписки.Количество() = ТекущийУровень Тогда
				Если ОткрытыеСписки.Количество() > 0 И ОткрытыеСписки[ОткрытыеСписки.ВГраница()] <> ИнфоСписка.ТипСписка Тогда
					// Закрываем список другого типа на том же уровне
					ТипЗакрываемогоСписка = ОткрытыеСписки[ОткрытыеСписки.ВГраница()];
					Если ТипЗакрываемогоСписка = "ul" Тогда
						Результат = Результат + "</ul>";
					Иначе
						Результат = Результат + "</ol>";
					КонецЕсли;
					ОткрытыеСписки.Удалить(ОткрытыеСписки.ВГраница());
					
					// Открываем список нужного типа
					Если ИнфоСписка.ТипСписка = "ul" Тогда
						Результат = Результат + "<ul style='margin:5px 0;padding-left:20px;'>";
					Иначе
						Результат = Результат + "<ol style='margin:5px 0;padding-left:20px;'>";
					КонецЕсли;
					ОткрытыеСписки.Добавить(ИнфоСписка.ТипСписка);
				ИначеЕсли ОткрытыеСписки.Количество() = 0 Тогда
					// Открываем первый список
					Если ИнфоСписка.ТипСписка = "ul" Тогда
						Результат = Результат + "<ul style='margin:5px 0;padding-left:20px;'>";
					Иначе
						Результат = Результат + "<ol style='margin:5px 0;padding-left:20px;'>";
					КонецЕсли;
					ОткрытыеСписки.Добавить(ИнфоСписка.ТипСписка);
				КонецЕсли;
			КонецЕсли;
			
			// Применяем markdown-форматирование к тексту элемента списка
			ОтформатированныйТекст = МД_ОтформатироватьInline(ИнфоСписка.Текст);
			Результат = Результат + "<li>" + ОтформатированныйТекст + "</li>";
			
			// Проверяем, не идет ли после текущего элемента еще один элемент списка того же типа
			// Если да, не закрываем список
			СледующийИндекс = Индекс + 1;
			Пока СледующийИндекс <= Строки.ВГраница() И ПустаяСтрока(СокрЛП(Строки[СледующийИндекс])) Цикл
				СледующийИндекс = СледующийИндекс + 1;
			КонецЦикла;
			
			// Если после пустых строк идет элемент списка того же типа, не закрываем список
			Если СледующийИндекс <= Строки.ВГраница() Тогда
				ИнфоСледующегоСписка = РазобратьЭлементСписка(Строки[СледующийИндекс]);
				Если ИнфоСледующегоСписка.ЭтоСписок И ОткрытыеСписки.Количество() > 0 Тогда
					ТипТекущегоСписка = ОткрытыеСписки[ОткрытыеСписки.ВГраница()];
					Если ТипТекущегоСписка = ИнфоСледующегоСписка.ТипСписка И ИнфоСледующегоСписка.УровеньВложенности = ТекущийУровень Тогда
						// Следующий элемент - того же типа и уровня, не закрываем список
						// (список будет продолжен на следующей итерации)
						Продолжить;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
		Иначе
			
			Если ПустаяСтрока(СокрЛП(Строка)) Тогда
				// Проверяем, не идет ли после пустой строки элемент списка того же типа
				СледующийИндекс = Индекс + 1;
				Пока СледующийИндекс <= Строки.ВГраница() И ПустаяСтрока(СокрЛП(Строки[СледующийИндекс])) Цикл
					СледующийИндекс = СледующийИндекс + 1;
				КонецЦикла;
				
				// Если после пустых строк идет элемент списка, не закрываем список
				Если СледующийИндекс <= Строки.ВГраница() Тогда
					ИнфоСледующегоСписка = РазобратьЭлементСписка(Строки[СледующийИндекс]);
					Если ИнфоСледующегоСписка.ЭтоСписок И ОткрытыеСписки.Количество() > 0 Тогда
						ТипТекущегоСписка = ОткрытыеСписки[ОткрытыеСписки.ВГраница()];
						Если ТипТекущегоСписка = ИнфоСледующегоСписка.ТипСписка Тогда
							// Следующий элемент - того же типа, не закрываем список
							Продолжить;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				// Закрываем все открытые списки
				Пока ОткрытыеСписки.Количество() > 0 Цикл
					ИндексСписка = ОткрытыеСписки.ВГраница();
					ТипЗакрываемогоСписка = ОткрытыеСписки[ИндексСписка];
					Если ТипЗакрываемогоСписка = "ul" Тогда
						Результат = Результат + "</ul>";
					Иначе
						Результат = Результат + "</ol>";
					КонецЕсли;
					ОткрытыеСписки.Удалить(ИндексСписка);
				КонецЦикла;
				Продолжить;
			КонецЕсли;
			
			// Закрываем все открытые списки
			Пока ОткрытыеСписки.Количество() > 0 Цикл
				ИндексСписка = ОткрытыеСписки.ВГраница();
				ТипЗакрываемогоСписка = ОткрытыеСписки[ИндексСписка];
				Если ТипЗакрываемогоСписка = "ul" Тогда
					Результат = Результат + "</ul>";
				Иначе
					Результат = Результат + "</ol>";
				КонецЕсли;
				ОткрытыеСписки.Удалить(ИндексСписка);
			КонецЦикла;
			
			Результат = Результат + Строка + Символы.ПС;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Закрываем все оставшиеся списки
	Пока ОткрытыеСписки.Количество() > 0 Цикл
		ИндексСписка = ОткрытыеСписки.ВГраница();
		ТипЗакрываемогоСписка = ОткрытыеСписки[ИндексСписка];
		Если ТипЗакрываемогоСписка = "ul" Тогда
			Результат = Результат + "</ul>";
		Иначе
			Результат = Результат + "</ol>";
		КонецЕсли;
		ОткрытыеСписки.Удалить(ИндексСписка);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция РазобратьЭлементСписка(Знач Строка)
	
	Результат = Новый Структура;
	Результат.Вставить("ЭтоСписок", Ложь);
	Результат.Вставить("ТипСписка", "");
	Результат.Вставить("Текст", Строка);
	Результат.Вставить("УровеньВложенности", 0);
	
	// Подсчитываем количество пробелов/табуляций в начале строки
	УровеньВложенности = 0;
	Для Индекс = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Индекс, 1);
		Если Символ = " " Тогда
			УровеньВложенности = УровеньВложенности + 1;
		ИначеЕсли Символ = Символы.Таб Тогда
			УровеньВложенности = УровеньВложенности + 4; // Табуляция = 4 пробела
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	// Определяем уровень вложенности (обычно 2 или 4 пробела на уровень)
	Результат.УровеньВложенности = Цел(УровеньВложенности / 2);
	
	ОбрезаннаяСтрока = СокрЛП(Строка);
	
	Если СтрНачинаетсяС(ОбрезаннаяСтрока, "* ") ИЛИ СтрНачинаетсяС(ОбрезаннаяСтрока, "- ") ИЛИ СтрНачинаетсяС(ОбрезаннаяСтрока, "+ ") Тогда
		Результат.ЭтоСписок = Истина;
		Результат.ТипСписка = "ul";
		Результат.Текст = СокрЛП(Сред(ОбрезаннаяСтрока, 3));
		Возврат Результат;
	КонецЕсли;
	
	Если ПроверитьНумерованныйСписок(ОбрезаннаяСтрока) Тогда
		Результат.ЭтоСписок = Истина;
		Результат.ТипСписка = "ol";
		Позиция = СтрНайти(ОбрезаннаяСтрока, ". ");
		Если Позиция > 0 Тогда
			Результат.Текст = СокрЛП(Сред(ОбрезаннаяСтрока, Позиция + 2));
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ПроверитьНумерованныйСписок(Знач Строка)
	
	Если ПустаяСтрока(Строка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Позиция = СтрНайти(Строка, ". ");
	Если Позиция = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ЧастьДоТочки = Лев(Строка, Позиция - 1);
	
	Если ПустаяСтрока(ЧастьДоТочки) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Индекс = 1 По СтрДлина(ЧастьДоТочки) Цикл
		Символ = Сред(ЧастьДоТочки, Индекс, 1);
		Код = КодСимвола(Символ);
		Если Код < 48 ИЛИ Код > 57 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ЭкранироватьHTML(Знач Текст)
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат "";
	КонецЕсли;
	
	Результат = Текст;
	Результат = СтрЗаменить(Результат, "&", "&amp;");
	Результат = СтрЗаменить(Результат, "<", "&lt;");
	Результат = СтрЗаменить(Результат, ">", "&gt;");
	Результат = СтрЗаменить(Результат, """", "&quot;");
	Результат = СтрЗаменить(Результат, "'", "&#39;");
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьИдентификаторПоСсылке(Знач Ссылка)

	Если Не ЗначениеЗаполнено(Ссылка) Тогда
		Возврат Неопределено;
	КонецЕсли;

	// Используем менеджер для получения идентификатора через запрос
	Возврат Справочники.onyx_СессииЧата.ПолучитьИдентификатор(Ссылка);

КонецФункции

// Создает таблицу правил преобразований Markdown в HTML
Функция СоздатьТаблицуПравилПреобразований()
	
	Правила = Новый ТаблицаЗначений;
	Правила.Колонки.Добавить("ОткрывающийТег", Новый ОписаниеТипов("Строка"));
	Правила.Колонки.Добавить("ЗакрывающийТег", Новый ОписаниеТипов("Строка"));
	Правила.Колонки.Добавить("ОткрывающийHTML", Новый ОписаниеТипов("Строка"));
	Правила.Колонки.Добавить("ЗакрывающийHTML", Новый ОписаниеТипов("Строка"));
	Правила.Колонки.Добавить("Приоритет", Новый ОписаниеТипов("Число"));
	Правила.Колонки.Добавить("ТипПравила", Новый ОписаниеТипов("Строка")); // "простая" или "с_проверкой"
	
	// Правила в порядке приоритета (больше приоритет = обрабатывается раньше)
	// Тройное подчеркивание (жирный курсив) - самый высокий приоритет
	Строка = Правила.Добавить();
	Строка.ОткрывающийТег = "___";
	Строка.ЗакрывающийТег = "___";
	Строка.ОткрывающийHTML = "<strong><em>";
	Строка.ЗакрывающийHTML = "</em></strong>";
	Строка.Приоритет = 100;
	Строка.ТипПравила = "простая";
	
	// Двойные звездочки (жирный)
	Строка = Правила.Добавить();
	Строка.ОткрывающийТег = "**";
	Строка.ЗакрывающийТег = "**";
	Строка.ОткрывающийHTML = "<strong>";
	Строка.ЗакрывающийHTML = "</strong>";
	Строка.Приоритет = 90;
	Строка.ТипПравила = "простая";
	
	// Двойное подчеркивание (жирный)
	Строка = Правила.Добавить();
	Строка.ОткрывающийТег = "__";
	Строка.ЗакрывающийТег = "__";
	Строка.ОткрывающийHTML = "<strong>";
	Строка.ЗакрывающийHTML = "</strong>";
	Строка.Приоритет = 80;
	Строка.ТипПравила = "с_проверкой"; // Нужно проверять, что это не тройное подчеркивание
	
	// Двойная тильда (зачеркнутый)
	Строка = Правила.Добавить();
	Строка.ОткрывающийТег = "~~";
	Строка.ЗакрывающийТег = "~~";
	Строка.ОткрывающийHTML = "<del>";
	Строка.ЗакрывающийHTML = "</del>";
	Строка.Приоритет = 70;
	Строка.ТипПравила = "простая";
	
	// Одинарная звездочка (курсив)
	Строка = Правила.Добавить();
	Строка.ОткрывающийТег = "*";
	Строка.ЗакрывающийТег = "*";
	Строка.ОткрывающийHTML = "<em>";
	Строка.ЗакрывающийHTML = "</em>";
	Строка.Приоритет = 60;
	Строка.ТипПравила = "с_проверкой"; // Нужно проверять, что это не двойная звездочка
	
	// Одинарное подчеркивание (курсив)
	Строка = Правила.Добавить();
	Строка.ОткрывающийТег = "_";
	Строка.ЗакрывающийТег = "_";
	Строка.ОткрывающийHTML = "<em>";
	Строка.ЗакрывающийHTML = "</em>";
	Строка.Приоритет = 50;
	Строка.ТипПравила = "с_проверкой"; // Нужно проверять, что это не двойное/тройное подчеркивание
	
	// Сортируем по приоритету (по убыванию)
	Правила.Сортировать("Приоритет Убыв");
	
	Возврат Правила;
	
КонецФункции

// Применяет правила преобразований Markdown к тексту
Функция ПрименитьПравилаПреобразованийMarkdown(Знач Текст)
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат Текст;
	КонецЕсли;
	
	Правила = СоздатьТаблицуПравилПреобразований();
	Результат = Текст;
	
	// Применяем каждое правило по очереди
	Для Каждого Правило Из Правила Цикл
		
		Если Правило.ТипПравила = "простая" Тогда
			Результат = ПрименитьПростоеПравило(Результат, Правило);
		ИначеЕсли Правило.ТипПравила = "с_проверкой" Тогда
			Результат = ПрименитьПравилоСПроверкой(Результат, Правило, Правила);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Применяет простое правило преобразования (без дополнительных проверок)
Функция ПрименитьПростоеПравило(Знач Текст, Правило)
	
	Результат = Текст;
	МаксимальноПопыток = 1000;
	Счетчик = 0;
	НачальнаяПозицияПоиска = 1;
	
	Пока Счетчик < МаксимальноПопыток Цикл
		
		ПодстрокаДляПоиска = Сред(Результат, НачальнаяПозицияПоиска);
		Позиция1Относительно = СтрНайти(ПодстрокаДляПоиска, Правило.ОткрывающийТег);
		Если Позиция1Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		Позиция1 = НачальнаяПозицияПоиска + Позиция1Относительно - 1;
		
		// Проверяем, не является ли это частью плейсхолдера (INLINECODE, HTMLTAG, CODEBLOCK)
		Если ЯвляетсяЧастьюПлейсхолдера(Результат, Позиция1) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		// Проверяем, не находится ли тег внутри HTML тега (например, <code>, <pre>, <a>)
		// Согласно лучшим практикам, markdown не должен обрабатываться внутри HTML тегов
		Если НаходитсяВнутриHTMLТега(Результат, Позиция1) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		ПодстрокаПослеОткрывающего = Сред(Результат, Позиция1 + СтрДлина(Правило.ОткрывающийТег));
		Позиция2Относительно = СтрНайти(ПодстрокаПослеОткрывающего, Правило.ЗакрывающийТег);
		Если Позиция2Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Позиция2 = Позиция1 + СтрДлина(Правило.ОткрывающийТег) + Позиция2Относительно - 1;
		
		// Проверяем, не является ли закрывающий тег частью плейсхолдера
		Если ЯвляетсяЧастьюПлейсхолдера(Результат, Позиция2) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		// Проверяем, не находится ли закрывающий тег внутри HTML тега
		Если НаходитсяВнутриHTMLТега(Результат, Позиция2) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		ТекстВнутри = Сред(Результат, Позиция1 + СтрДлина(Правило.ОткрывающийТег), Позиция2 - Позиция1 - СтрДлина(Правило.ОткрывающийТег));
		HTMLТекст = Правило.ОткрывающийHTML + ТекстВнутри + Правило.ЗакрывающийHTML;
		
		Результат = Лев(Результат, Позиция1 - 1) + HTMLТекст + Сред(Результат, Позиция2 + СтрДлина(Правило.ЗакрывающийТег));
		НачальнаяПозицияПоиска = Позиция1 + СтрДлина(HTMLТекст);
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Применяет правило с проверкой контекста (чтобы не конфликтовало с другими правилами)
Функция ПрименитьПравилоСПроверкой(Знач Текст, Правило, ВсеПравила)
	
	Результат = Текст;
	МаксимальноПопыток = 1000;
	Счетчик = 0;
	НачальнаяПозицияПоиска = 1;
	
	Пока Счетчик < МаксимальноПопыток Цикл
		
		ПодстрокаДляПоиска = Сред(Результат, НачальнаяПозицияПоиска);
		Позиция1Относительно = СтрНайти(ПодстрокаДляПоиска, Правило.ОткрывающийТег);
		Если Позиция1Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		Позиция1 = НачальнаяПозицияПоиска + Позиция1Относительно - 1;
		
		// Проверяем, не является ли это частью плейсхолдера (INLINECODE, HTMLTAG, CODEBLOCK)
		Если ЯвляетсяЧастьюПлейсхолдера(Результат, Позиция1) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		// Проверяем, не находится ли тег внутри HTML тега
		Если НаходитсяВнутриHTMLТега(Результат, Позиция1) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		// Проверяем, не является ли это частью более длинного тега из других правил
		Если НЕ ПроверитьКонтекстПравила(Результат, Позиция1, Правило, ВсеПравила) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		ПодстрокаПослеОткрывающего = Сред(Результат, Позиция1 + СтрДлина(Правило.ОткрывающийТег));
		Позиция2Относительно = СтрНайти(ПодстрокаПослеОткрывающего, Правило.ЗакрывающийТег);
		Если Позиция2Относительно = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Позиция2 = Позиция1 + СтрДлина(Правило.ОткрывающийТег) + Позиция2Относительно - 1;
		
		// Проверяем, не является ли закрывающий тег частью плейсхолдера
		Если ЯвляетсяЧастьюПлейсхолдера(Результат, Позиция2) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		// Проверяем, не находится ли закрывающий тег внутри HTML тега
		Если НаходитсяВнутриHTMLТега(Результат, Позиция2) Тогда
			НачальнаяПозицияПоиска = Позиция1 + 1;
			Счетчик = Счетчик + 1;
			Продолжить;
		КонецЕсли;
		
		ТекстВнутри = Сред(Результат, Позиция1 + СтрДлина(Правило.ОткрывающийТег), Позиция2 - Позиция1 - СтрДлина(Правило.ОткрывающийТег));
		HTMLТекст = Правило.ОткрывающийHTML + ТекстВнутри + Правило.ЗакрывающийHTML;
		
		Результат = Лев(Результат, Позиция1 - 1) + HTMLТекст + Сред(Результат, Позиция2 + СтрДлина(Правило.ЗакрывающийТег));
		НачальнаяПозицияПоиска = Позиция1 + СтрДлина(HTMLТекст);
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверяет, находится ли позиция внутри HTML тега (например, <code>, <pre>, <a>)
// Согласно лучшим практикам, markdown не должен обрабатываться внутри HTML тегов
Функция НаходитсяВнутриHTMLТега(Знач Текст, Позиция)
	
	Если Позиция < 1 ИЛИ Позиция > СтрДлина(Текст) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Список HTML тегов, внутри которых markdown не должен обрабатываться
	// Включаем все теги, которые могут содержать уже обработанный контент
	ЗащищенныеТеги = Новый Массив;
	ЗащищенныеТеги.Добавить("code");
	ЗащищенныеТеги.Добавить("pre");
	ЗащищенныеТеги.Добавить("script");
	ЗащищенныеТеги.Добавить("style");
	ЗащищенныеТеги.Добавить("kbd");
	ЗащищенныеТеги.Добавить("h1");
	ЗащищенныеТеги.Добавить("h2");
	ЗащищенныеТеги.Добавить("h3");
	ЗащищенныеТеги.Добавить("h4");
	ЗащищенныеТеги.Добавить("h5");
	ЗащищенныеТеги.Добавить("h6");
	ЗащищенныеТеги.Добавить("a"); // Ссылки уже обработаны
	ЗащищенныеТеги.Добавить("strong"); // Жирный текст уже обработан
	ЗащищенныеТеги.Добавить("em"); // Курсив уже обработан
	ЗащищенныеТеги.Добавить("del"); // Зачеркнутый текст уже обработан
	ЗащищенныеТеги.Добавить("table"); // Таблицы уже обработаны
	ЗащищенныеТеги.Добавить("th"); // Ячейки заголовков таблиц
	ЗащищенныеТеги.Добавить("td"); // Ячейки таблиц
	ЗащищенныеТеги.Добавить("li"); // Элементы списков
	
	// Ищем открывающий тег перед позицией
	НачалоПоиска = Макс(1, Позиция - 200); // Проверяем до 200 символов назад
	ПодстрокаДоПозиции = Сред(Текст, НачалоПоиска, Позиция - НачалоПоиска);
	
	Для Каждого Тег Из ЗащищенныеТеги Цикл
		ОткрывающийТег = "<" + Тег + ">";
		ЗакрывающийТег = "</" + Тег + ">";
		
		// Ищем все открывающие теги перед позицией (ищем с конца)
		ТекущаяПозицияПоиска = СтрДлина(ПодстрокаДоПозиции);
		Пока ТекущаяПозицияПоиска > 0 Цикл
			ПодстрокаДляПоиска = Сред(ПодстрокаДоПозиции, 1, ТекущаяПозицияПоиска);
			ПозицияОткрытия = СтрНайти(ПодстрокаДляПоиска, ОткрывающийТег, , ТекущаяПозицияПоиска);
			Если ПозицияОткрытия = 0 Тогда
				Прервать;
			КонецЕсли;
			
			// Нашли открывающий тег, проверяем, есть ли закрывающий тег после него
			АбсолютнаяПозицияОткрытия = НачалоПоиска + ПозицияОткрытия - 1;
			ПодстрокаПослеОткрытия = Сред(Текст, АбсолютнаяПозицияОткрытия + СтрДлина(ОткрывающийТег));
			ПозицияЗакрытияОтносительно = СтрНайти(ПодстрокаПослеОткрытия, ЗакрывающийТег);
			
			Если ПозицияЗакрытияОтносительно > 0 Тогда
				АбсолютнаяПозицияЗакрытия = АбсолютнаяПозицияОткрытия + СтрДлина(ОткрывающийТег) + ПозицияЗакрытияОтносительно - 1;
				// Проверяем, попадает ли текущая позиция между открывающим и закрывающим тегом
				Если Позиция > АбсолютнаяПозицияОткрытия И Позиция < АбсолютнаяПозицияЗакрытия Тогда
					Возврат Истина;
				КонецЕсли;
			КонецЕсли;
			
			// Ищем следующий тег раньше
			ТекущаяПозицияПоиска = ПозицияОткрытия - 1;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет, является ли позиция частью плейсхолдера (INLINECODE, HTMLTAG, CODEBLOCK)
Функция ЯвляетсяЧастьюПлейсхолдера(Знач Текст, Позиция)
	
// Плейсхолдеры имеют формат: <<MD_ТИП_INDEX>>
// Ищем начало плейсхолдера, проверяя символы перед позицией
	
	Если Позиция < 5 ИЛИ Позиция > СтрДлина(Текст) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверяем, есть ли маркер плейсхолдера в окрестности позиции
	НачалоПроверки = Макс(1, Позиция - 80); // Проверяем до 80 символов назад
	КонецПроверки = Мин(СтрДлина(Текст), Позиция + 80); // И до 80 символов вперед
	ПодстрокаДляПроверки = Сред(Текст, НачалоПроверки, КонецПроверки - НачалоПроверки + 1);
	
	МаркерПрефикс = "<<MD_";
	МаркерСуффикс = ">>";
	
	ПозицияМаркераОтносительно = СтрНайти(ПодстрокаДляПроверки, МаркерПрефикс);
	Пока ПозицияМаркераОтносительно > 0 Цикл
		АбсолютнаяПозицияМаркера = НачалоПроверки + ПозицияМаркераОтносительно - 1;
		
		ПодстрокаПослеМаркера = Сред(Текст, АбсолютнаяПозицияМаркера + СтрДлина(МаркерПрефикс));
		ПозицияКонцаОтносительно = СтрНайти(ПодстрокаПослеМаркера, МаркерСуффикс);
		
		Если ПозицияКонцаОтносительно > 0 Тогда
			КонецПлейсхолдера = АбсолютнаяПозицияМаркера + СтрДлина(МаркерПрефикс) + ПозицияКонцаОтносительно + СтрДлина(МаркерСуффикс) - 1;
			Если Позиция >= АбсолютнаяПозицияМаркера И Позиция <= КонецПлейсхолдера Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
		
		СледующаяПозиция = ПозицияМаркераОтносительно + СтрДлина(МаркерПрефикс);
		Если СледующаяПозиция < СтрДлина(ПодстрокаДляПроверки) Тогда
			ПодстрокаПослеНайденного = Сред(ПодстрокаДляПроверки, СледующаяПозиция);
			ПозицияМаркераОтносительно = СтрНайти(ПодстрокаПослеНайденного, МаркерПрефикс);
			Если ПозицияМаркераОтносительно > 0 Тогда
				ПозицияМаркераОтносительно = СледующаяПозиция + ПозицияМаркераОтносительно - 1;
			Иначе
				ПозицияМаркераОтносительно = 0;
			КонецЕсли;
		Иначе
			ПозицияМаркераОтносительно = 0;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет, что найденный тег не является частью более длинного тега из других правил
Функция ПроверитьКонтекстПравила(Знач Текст, Позиция, ТекущееПравило, ВсеПравила)
	
	// Проверяем, нет ли более длинных тегов, которые начинаются с текущего
	// (более длинные теги уже обработаны, так как имеют больший приоритет)
	Для Каждого Правило Из ВсеПравила Цикл
		
		Если Правило.Приоритет > ТекущееПравило.Приоритет Тогда
			
			// Проверяем, начинается ли более длинный тег с текущей позиции
			// Более длинный тег должен начинаться с того же символа, что и текущий
			Если СтрНачинаетсяС(Правило.ОткрывающийТег, ТекущееПравило.ОткрывающийТег) И 
			   СтрДлина(Правило.ОткрывающийТег) > СтрДлина(ТекущееПравило.ОткрывающийТег) Тогда
				
				// Проверяем, есть ли следующий символ, который делает тег более длинным
				ПозицияСледующегоСимвола = Позиция + СтрДлина(ТекущееПравило.ОткрывающийТег);
				Если ПозицияСледующегоСимвола <= СтрДлина(Текст) Тогда
					СледующийСимвол = Сред(Текст, ПозицияСледующегоСимвола, 1);
					ОжидаемыйСимвол = Сред(Правило.ОткрывающийТег, СтрДлина(ТекущееПравило.ОткрывающийТег) + 1, 1);
					Если СледующийСимвол = ОжидаемыйСимвол Тогда
						// Это часть более длинного тега, пропускаем
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Проверяет и восстанавливает оставшиеся плейсхолдеры в тексте
// Это критически важно для предотвращения появления необработанных плейсхолдеров в финальном HTML

#КонецОбласти

#Область Инициализация

#КонецОбласти

#КонецЕсли
